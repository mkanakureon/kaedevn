# **KNF Visual Novel Script — 上級インタプリタ仕様書 v2**

## **1\. 概要**

### **1.1 目的**

本文書は、KNF (Kaede Novel Framework) の上級スクリプト記法を解釈・実行するインタプリタの仕様・設計を定義する。

### **1.2 設計思想**

* **セリフとロジックの境界がない** — JSライクな構文でセリフ・演出・ロジックがフラットに共存する  
* **JavaScriptのサブセット** — if、変数、関数、サブルーチンが自然に書ける  
* **変数は変数として扱う** — 文字列化→再パースの無駄を排除。変数が最初から最後まで変数として生きる  
* **演出の複雑さはタイムラインに委譲** — インタプリタは演出の詳細を持たない  
* **初級（@記法）からの変換先** — 初級スクリプトはこの上級形式に変換され保存・実行される  
* **クロスプラットフォーム** — TypeScript（Web）とC\#（Unity）の双方で同一仕様のインタプリタを実装する

### **1.3 アーキテクチャ全体像**

初級(@記法) → コンパイラ → 上級スクリプト(.knf)  
                                  ↓  
                            上級インタプリタ ← タイムラインJSON（エディタ生成）  
                                  ↓  
                          IEngineAPI（インターフェース）  
                                  ↓  
                    ┌─────────────┴─────────────┐  
                    │                           │  
              Web (TypeScript)            Unity (C\#)  
              PixiJS / WebAudio           Unity API

### **1.4 クロスプラットフォーム設計方針**

インタプリタのコアロジック（パーサー、式評価器、実行制御）は言語非依存で設計する。 プラットフォーム固有の部分は `IEngineAPI` インターフェースの実装に集約する。

| レイヤー | 内容 | プラットフォーム依存 |
| ----- | ----- | ----- |
| スクリプト (.knf) | テキストファイル | なし |
| タイムライン (.json) | JSONファイル | なし |
| Parser | 行分類、ブロック検出 | なし |
| Evaluator | 式評価、再帰下降パーサー | なし |
| Interpreter | メインループ、フロー制御 | なし |
| GameState | 変数、コールスタック | なし |
| セーブデータ (.json) | JSONファイル | なし |
| **IEngineAPI** | **描画、音声、UI** | **あり** |

#### **TypeScript / C\# 型対応表**

| 概念 | TypeScript | C\# |
| ----- | ----- | ----- |
| 辞書型 | `Map<string, any>` | `Dictionary<string, object>` |
| 配列 | `string[]` | `string[]` |
| 非同期 | `Promise<void>` / `await` | `Task` / `async await` |
| null許容 | `string | null` | `string?` |
| 列挙型 | `enum` | `enum` |
| インターフェース | `interface` | `interface` |
| 動的型 | `any` | `object` |
| ラムダ | `() => {}` | `() => {}` |

**設計原則: インタプリタのコアコードをTypeScriptで書いた場合、C\#への移植は型名の置き換えが主な作業となるよう設計する。ロジックの変更は発生させない。**

---

## **2\. スクリプト構文仕様**

### **2.1 行種別の判定**

インタプリタは各行の先頭文字で種別を判定する。

| 行頭パターン | 種別 | 例 |
| ----- | ----- | ----- |
| `#名前` | セリフ開始 | `#hero` |
| `#`（単体） | セリフ終了 | `#` |
| `*` | ラベル定義 | `*告白シーン` |
| `//` | コメント | `// ここから第2章` |
| 空行 | 無視 |  |
| それ以外 | JS式/文 | `affection += 1` |

**クロスプラットフォーム注記:** 行種別の判定は `line[0]` の1文字比較で完結する。文字列操作はTypeScript/C\#で同一のロジック。C\#では `line.TrimStart()` → `line[0]` で判定。

### **2.2 セリフブロック**

キャラクターの発言を `#キャラ名` で開始し、`#` で閉じる。

\#hero  
おはよう、今日もいい天気だな  
まだ眠いけどな  
\#

\#heroine  
うん、そうだね  
\#

#### **規則**

* `#名前` から `#` までの間の行はすべてテキストとして扱う  
* 複数行のテキストを含むことができる  
* セリフブロック内では JS 式やコマンドは評価されない（純粋なテキスト）  
* テキスト内の `{式}` は文字列補間として評価される（2.8節参照）

### **2.3 ラベル**

スクリプト内のジャンプ先を定義する。

\*オープニング  
\*告白シーン  
\*エンディングA

#### **規則**

* `*` の直後にラベル名が続く（スペースなし、または1スペースの後）  
* ラベル名は日本語・英数字・アンダースコアを許容  
* スクリプトロード時にラベル位置をインデックス化

// TypeScript  
labelMap: Map\<string, number\>

// C\#  
Dictionary\<string, int\> labelMap;

### **2.4 変数**

#### **2.4.1 宣言と代入**

変数は代入時に暗黙的に生成される。型は動的。

affection \= 0  
name \= "太郎"  
flag\_library \= false  
route \= "normal"

#### **2.4.2 複合代入演算子**

affection \+= 1  
affection \-= 2  
tension \*= 1.5

#### **2.4.3 スコープ**

| スコープ | 説明 |
| ----- | ----- |
| グローバル | スクリプト全体で共有。ゲーム状態変数 |
| ローカル | 関数内で宣言された変数。関数終了時に破棄 |

// TypeScript  
variables: Map\<string, any\>

// C\#  
Dictionary\<string, object\> variables;

関数呼び出し時にローカルスコープを生成し、チェーンで参照解決する。

#### **2.4.4 予約変数**

エンジンが自動的に管理する変数。スクリプトから読み取り可能。

| 変数名 | 型 | 説明 |
| ----- | ----- | ----- |
| `_chapter` | string | 現在のチャプター名 |
| `_scene` | string | 現在のシーン名 |
| `_play_count` | number | 周回数 |
| `_elapsed` | number | 経過時間（秒） |

### **2.5 演算子**

#### **2.5.1 算術演算子**

| 演算子 | 意味 |
| ----- | ----- |
| `+` | 加算（数値）/ 文字列結合 |
| `-` | 減算 |
| `*` | 乗算 |
| `/` | 除算 |
| `%` | 剰余 |

#### **2.5.2 比較演算子**

| 演算子 | 意味 |
| ----- | ----- |
| `==` | 等値 |
| `!=` | 不等値 |
| `>` | より大きい |
| `<` | より小さい |
| `>=` | 以上 |
| `<=` | 以下 |

#### **2.5.3 論理演算子**

| 演算子 | 意味 |
| ----- | ----- |
| `&&` | AND |
| `||` | OR |
| `!` | NOT |

#### **2.5.4 演算子の優先順位**

標準的なC/JavaScript の演算子優先順位に準拠する。 `()` による明示的なグループ化をサポート。

**クロスプラットフォーム注記:** 演算子優先順位はC言語由来でありTypeScript/C\#共通。再帰下降パーサーの優先順位テーブルは両言語で同一の構造となる。

### **2.6 制御構文**

#### **2.6.1 if / else if / else**

if (affection \>= 8 && flag\_library) {  
  \#heroine  
  話したいことがあるの  
  \#  
  jump("告白")  
} else if (affection \>= 5\) {  
  \#heroine  
  また明日ね  
  \#  
} else {  
  \#heroine  
  じゃあね  
  \#  
}

#### **2.6.2 choice（選択肢）**

プレイヤーに選択肢を提示し、選択結果に応じた処理を実行する。

choice {  
  "いいよ" {  
    affection \+= 1  
    jump("一緒に帰る")  
  }  
  "用事がある" {  
    affection \-= 1  
    jump("断る")  
  }  
  "図書室に行く" if (affection \>= 3\) {  
    jump("図書室")  
  }  
}

#### **規則**

* 各選択肢は `"テキスト"` で開始  
* `if (条件)` を付加すると、条件を満たす場合のみ選択肢を表示  
* 選択肢ブロック `{ }` 内の処理は選択時に実行される  
* choice は await ポイント（プレイヤー入力待ち）

#### **2.6.3 while（将来拡張）**

while (count \< 3\) {  
  \#heroine  
  まだ足りないわ  
  \#  
  count \+= 1  
}

基本的にノベルゲームでは不要だが、演出やミニゲーム連携で利用可能とする。

### **2.7 関数**

#### **2.7.1 関数定義（def）**

値を返す再利用可能なロジック。

def mood(aff) {  
  if (aff \>= 8\) return "happy"  
  if (aff \>= 4\) return "normal"  
  return "sad"  
}

#### **2.7.2 サブルーチン定義（sub）**

値を返さない。セリフや演出コマンドの再利用に使う。

sub morning\_greeting() {  
  bg("school")  
  \#hero  
  おはよう  
  \#  
}

#### **2.7.3 関数呼び出し**

// 値を使う  
show\_expression \= mood(affection)

// サブルーチンを呼ぶ  
morning\_greeting()

#### **2.7.4 関数のスコープ規則**

* 引数はローカルスコープに束縛される  
* 関数内で宣言した変数はローカル  
* グローバル変数へのアクセスは可能（読み書き両方）  
* ネスト定義は禁止（フラットな関数一覧）  
* 再帰呼び出しは許可するが、深度上限を設定（デフォルト: 16）

### **2.8 文字列補間**

セリフ内およびJSの文字列リテラル内で `{式}` を評価して埋め込む。

\#hero  
{name}さん、好感度は{affection}だよ  
\#

message \= "{name}のスコアは{score \* 10}点"

### **2.9 組み込みコマンド（関数）**

演出やゲーム制御のために、インタプリタに組み込まれた関数群。 これらはすべて `IEngineAPI` インターフェース経由で実行される。

#### **2.9.1 シーン・背景**

| 関数 | 説明 |
| ----- | ----- |
| `bg(name)` | 背景を設定 |
| `bg(name, effect)` | 背景をエフェクト付きで設定 |

#### **2.9.2 キャラクター**

| 関数 | 説明 |
| ----- | ----- |
| `ch(name, pose)` | キャラ表示 |
| `ch(name, pose, position)` | キャラ表示（位置指定） |
| `ch_hide(name)` | キャラ非表示 |
| `ch_move(name, position, time)` | キャラ移動 |

#### **2.9.3 オーディオ**

| 関数 | 説明 |
| ----- | ----- |
| `bgm(name)` | BGM再生 |
| `bgm_stop()` | BGM停止 |
| `bgm_fade(time)` | BGMフェードアウト |
| `se(name)` | 効果音再生 |

#### **2.9.4 ゲーム制御**

| 関数 | 説明 |
| ----- | ----- |
| `jump(label)` | ラベルへジャンプ |
| `call(label)` | サブルーチン呼び出し（戻れる） |
| `ret()` | call元に戻る |
| `wait(ms)` | 指定ミリ秒待機 |
| `waitclick()` | クリック待ち |

#### **2.9.5 タイムライン**

| 関数 | 説明 |
| ----- | ----- |
| `timeline(name)` | タイムラインJSONを名前で実行 |

タイムラインの中身はタイムラインエディタで作成し、JSONとして保存される。 スクリプトからは名前で参照するだけ。

#### **2.9.6 システム**

| 関数 | 説明 |
| ----- | ----- |
| `save()` | セーブポイント設定 |
| `load_scene(file)` | 別スクリプトファイルを実行 |
| `log(value)` | デバッグログ出力 |

---

## **3\. インタプリタ設計**

### **3.1 全体構成**

┌─────────────────────────────────────────────┐  
│               Interpreter                    │  
│                                              │  
│  ┌──────────┐  ┌──────────┐  ┌───────────┐  │  
│  │  Parser   │  │ Evaluator │  │  Runtime  │  │  
│  │          │  │          │  │           │  │  
│  │ 行解析    │→│ 式評価    │→│ 実行制御   │  │  
│  │ ブロック  │  │ 変数解決  │  │ await管理 │  │  
│  │ 構文判定  │  │ 関数呼出  │  │ フロー制御│  │  
│  └──────────┘  └──────────┘  └───────────┘  │  
│                      ↓                       │  
│              ┌──────────────┐                │  
│              │  GameState    │                │  
│              │              │                │  
│              │ variables     │                │  
│              │ callStack     │                │  
│              │ labelMap      │                │  
│              │ functions     │                │  
│              └──────────────┘                │  
│                      ↓                       │  
│              ┌──────────────┐                │  
│              │ IEngineAPI    │ ← インターフェース │  
│              └──────┬───────┘                │  
│                     │                        │  
└─────────────────────┼────────────────────────┘  
                      │  
          ┌───────────┴───────────┐  
          │                       │  
   PixiJSEngineAPI          UnityEngineAPI  
   (TypeScript)              (C\#)

### **3.2 主要クラス/モジュール**

すべてのクラスをTypeScriptとC\#の両方で示す。

#### **3.2.1 Interpreter（メインクラス）**

// \=== TypeScript \===  
class Interpreter {  
  private lines: string\[\]  
  private pc: number  
  private state: GameState  
  private engine: IEngineAPI  
  private parser: Parser  
  private evaluator: Evaluator

  async run(): Promise\<void\>  
  async step(): Promise\<void\>  
  pause(): void  
  resume(): void  
  jumpTo(label: string): void  
}

// \=== C\# \===  
public class Interpreter {  
    private string\[\] lines;  
    private int pc;  
    private GameState state;  
    private IEngineAPI engine;  
    private Parser parser;  
    private Evaluator evaluator;

    public async Task Run()  
    public async Task Step()  
    public void Pause()  
    public void Resume()  
    public void JumpTo(string label)  
}

#### **3.2.2 GameState（状態管理）**

// \=== TypeScript \===  
class GameState {  
  variables: Map\<string, any\>  
  localScopes: Map\<string, any\>\[\]  
  callStack: number\[\]  
  labelMap: Map\<string, number\>  
  functions: Map\<string, FunctionDef\>  
  subroutines: Map\<string, FunctionDef\>

  getVar(name: string): any  
  setVar(name: string, value: any): void  
  pushScope(): void  
  popScope(): void  
}

interface FunctionDef {  
  name: string  
  params: string\[\]  
  bodyStart: number  
  bodyEnd: number  
}

// \=== C\# \===  
public class GameState {  
    public Dictionary\<string, object\> Variables { get; }  
    public Stack\<Dictionary\<string, object\>\> LocalScopes { get; }  
    public Stack\<int\> CallStack { get; }  
    public Dictionary\<string, int\> LabelMap { get; }  
    public Dictionary\<string, FunctionDef\> Functions { get; }  
    public Dictionary\<string, FunctionDef\> Subroutines { get; }

    public object GetVar(string name)  
    public void SetVar(string name, object value)  
    public void PushScope()  
    public void PopScope()  
}

public class FunctionDef {  
    public string Name { get; set; }  
    public string\[\] Params { get; set; }  
    public int BodyStart { get; set; }  
    public int BodyEnd { get; set; }  
}

#### **3.2.3 Parser（構文解析）**

// \=== TypeScript \===  
class Parser {  
  classifyLine(line: string): LineType  
  findDialogueEnd(lines: string\[\], start: number): number  
  findBlockEnd(lines: string\[\], start: number): number  
  tokenize(expr: string): Token\[\]  
  parseChoice(lines: string\[\], start: number): ChoiceNode  
  parseIf(lines: string\[\], start: number): IfNode  
  parseFunctionDef(lines: string\[\], start: number): FunctionDef  
}

enum LineType {  
  DialogueStart,  
  DialogueEnd,  
  Label,  
  Comment,  
  Empty,  
  Expression,  
}

// \=== C\# \===  
public class Parser {  
    public LineType ClassifyLine(string line)  
    public int FindDialogueEnd(string\[\] lines, int start)  
    public int FindBlockEnd(string\[\] lines, int start)  
    public Token\[\] Tokenize(string expr)  
    public ChoiceNode ParseChoice(string\[\] lines, int start)  
    public IfNode ParseIf(string\[\] lines, int start)  
    public FunctionDef ParseFunctionDef(string\[\] lines, int start)  
}

public enum LineType {  
    DialogueStart,  
    DialogueEnd,  
    Label,  
    Comment,  
    Empty,  
    Expression,  
}

#### **3.2.4 Evaluator（式評価）**

// \=== TypeScript \===  
class Evaluator {  
  evaluate(expr: string, state: GameState): any  
  executeAssignment(expr: string, state: GameState): void  
  evaluateCondition(expr: string, state: GameState): boolean  
  callFunction(name: string, args: any\[\], state: GameState): any  
  interpolate(text: string, state: GameState): string  
}

// \=== C\# \===  
public class Evaluator {  
    public object Evaluate(string expr, GameState state)  
    public void ExecuteAssignment(string expr, GameState state)  
    public bool EvaluateCondition(string expr, GameState state)  
    public object CallFunction(string name, object\[\] args, GameState state)  
    public string Interpolate(string text, GameState state)  
}

#### **3.2.5 IEngineAPI（エンジンインターフェース）**

**唯一のプラットフォーム依存部。このインターフェースだけ各プラットフォームで実装する。**

// \=== TypeScript \===  
interface IEngineAPI {  
  // セリフ  
  showDialogue(speaker: string, lines: string\[\]): Promise\<void\>

  // 背景  
  setBg(name: string, effect?: string): Promise\<void\>

  // キャラクター  
  showChar(name: string, pose: string, position?: string): Promise\<void\>  
  hideChar(name: string): Promise\<void\>  
  moveChar(name: string, position: string, time: number): Promise\<void\>

  // オーディオ  
  playBgm(name: string): void  
  stopBgm(): void  
  fadeBgm(time: number): Promise\<void\>  
  playSe(name: string): void

  // タイムライン  
  playTimeline(name: string): Promise\<void\>

  // UI  
  showChoice(options: ChoiceOption\[\]): Promise\<number\>  
  waitForClick(): Promise\<void\>  
  wait(ms: number): Promise\<void\>  
}

interface ChoiceOption {  
  text: string  
  condition?: boolean  
}

// \=== C\# \===  
public interface IEngineAPI {  
    // セリフ  
    Task ShowDialogue(string speaker, string\[\] lines);

    // 背景  
    Task SetBg(string name, string effect \= null);

    // キャラクター  
    Task ShowChar(string name, string pose, string position \= null);  
    Task HideChar(string name);  
    Task MoveChar(string name, string position, int time);

    // オーディオ  
    void PlayBgm(string name);  
    void StopBgm();  
    Task FadeBgm(int time);  
    void PlaySe(string name);

    // タイムライン  
    Task PlayTimeline(string name);

    // UI  
    Task\<int\> ShowChoice(ChoiceOption\[\] options);  
    Task WaitForClick();  
    Task Wait(int ms);  
}

public class ChoiceOption {  
    public string Text { get; set; }  
    public bool Condition { get; set; } \= true;  
}

#### **3.2.6 プラットフォーム別 IEngineAPI 実装例**

// \=== Web: PixiJS実装 \===  
class PixiJSEngineAPI implements IEngineAPI {  
  private app: PIXI.Application  
  private timelineRunner: TimelineRunner

  async showDialogue(speaker: string, lines: string\[\]): Promise\<void\> {  
    this.textBox.setSpeaker(speaker)  
    this.textBox.setText(lines.join("\\n"))  
    await this.waitForClick()  
  }

  async setBg(name: string, effect?: string): Promise\<void\> {  
    const texture \= await PIXI.Assets.load(\`bg/${name}.webp\`)  
    if (effect \=== "fade") {  
      await this.transition.crossFade(texture, 1000\)  
    } else {  
      this.bgSprite.texture \= texture  
    }  
  }

  async playTimeline(name: string): Promise\<void\> {  
    const json \= await fetch(\`timelines/${name}.json\`).then(r \=\> r.json())  
    await this.timelineRunner.play(json)  
  }  
  // ...  
}

// \=== Unity: Unity実装 \===  
public class UnityEngineAPI : IEngineAPI {  
    private DialogueUI dialogueUI;  
    private TimelineRunner timelineRunner;

    public async Task ShowDialogue(string speaker, string\[\] lines) {  
        dialogueUI.SetSpeaker(speaker);  
        dialogueUI.SetText(string.Join("\\n", lines));  
        await WaitForClick();  
    }

    public async Task SetBg(string name, string effect \= null) {  
        var sprite \= Resources.Load\<Sprite\>($"Backgrounds/{name}");  
        if (effect \== "fade") {  
            await TransitionManager.CrossFade(sprite, 1.0f);  
        } else {  
            backgroundRenderer.sprite \= sprite;  
        }  
    }

    public async Task PlayTimeline(string name) {  
        var json \= Resources.Load\<TextAsset\>($"Timelines/{name}");  
        await timelineRunner.Play(json.text);  
    }  
    // ...  
}

### **3.3 メインループ**

// \=== TypeScript \===  
async run(): Promise\<void\> {  
  this.indexLabelsAndFunctions()

  while (this.pc \< this.lines.length) {  
    const line \= this.lines\[this.pc\].trim()

    if (line \=== "" || line.startsWith("//")) {  
      this.pc++  
      continue  
    }

    if (line.startsWith("def ") || line.startsWith("sub ")) {  
      this.pc \= this.parser.findBlockEnd(this.lines, this.pc) \+ 1  
      continue  
    }

    const type \= this.parser.classifyLine(line)

    switch (type) {  
      case LineType.DialogueStart:  
        await this.handleDialogue(line)  
        break  
      case LineType.DialogueEnd:  
        this.pc++  
        break  
      case LineType.Label:  
        this.pc++  
        break  
      case LineType.Expression:  
        await this.handleExpression(line)  
        break  
    }  
  }  
}

// \=== C\# \===  
public async Task Run() {  
    IndexLabelsAndFunctions();

    while (pc \< lines.Length) {  
        var line \= lines\[pc\].Trim();

        if (line \== "" || line.StartsWith("//")) {  
            pc++;  
            continue;  
        }

        if (line.StartsWith("def ") || line.StartsWith("sub ")) {  
            pc \= parser.FindBlockEnd(lines, pc) \+ 1;  
            continue;  
        }

        var type \= parser.ClassifyLine(line);

        switch (type) {  
            case LineType.DialogueStart:  
                await HandleDialogue(line);  
                break;  
            case LineType.DialogueEnd:  
                pc++;  
                break;  
            case LineType.Label:  
                pc++;  
                break;  
            case LineType.Expression:  
                await HandleExpression(line);  
                break;  
        }  
    }  
}

**クロスプラットフォーム注記:** 上記の通り、メインループのロジックはTypeScriptとC\#でほぼ同一。違いは命名規則（camelCase vs PascalCase）と型宣言の構文のみ。

### **3.4 セリフ処理**

// \=== TypeScript \===  
async handleDialogue(line: string): Promise\<void\> {  
  const speaker \= line.slice(1).trim()  
  this.pc++

  const textLines: string\[\] \= \[\]  
  while (this.pc \< this.lines.length) {  
    const current \= this.lines\[this.pc\].trim()  
    if (current \=== "\#") {  
      this.pc++  
      break  
    }  
    textLines.push(this.evaluator.interpolate(current, this.state))  
    this.pc++  
  }

  await this.engine.showDialogue(speaker, textLines)  
}

// \=== C\# \===  
private async Task HandleDialogue(string line) {  
    var speaker \= line.Substring(1).Trim();  
    pc++;

    var textLines \= new List\<string\>();  
    while (pc \< lines.Length) {  
        var current \= lines\[pc\].Trim();  
        if (current \== "\#") {  
            pc++;  
            break;  
        }  
        textLines.Add(evaluator.Interpolate(current, state));  
        pc++;  
    }

    await engine.ShowDialogue(speaker, textLines.ToArray());  
}

### **3.5 JS式/文の処理**

// \=== TypeScript \===  
async handleExpression(line: string): Promise\<void\> {  
  if (line.startsWith("if ") || line.startsWith("if(")) {  
    await this.handleIf(line)  
    return  
  }

  if (line.startsWith("choice ") || line \=== "choice{" || line.startsWith("choice {")) {  
    await this.handleChoice()  
    return  
  }

  if (line.startsWith("while ") || line.startsWith("while(")) {  
    await this.handleWhile(line)  
    return  
  }

  if (line.startsWith("return ") || line \=== "return") {  
    this.handleReturn(line)  
    return  
  }

  if (this.isBuiltinCall(line)) {  
    await this.executeBuiltin(line)  
    this.pc++  
    return  
  }

  if (this.isUserFunctionCall(line)) {  
    await this.executeUserFunction(line)  
    this.pc++  
    return  
  }

  this.evaluator.executeAssignment(line, this.state)  
  this.pc++  
}

// \=== C\# \===  
private async Task HandleExpression(string line) {  
    if (line.StartsWith("if ") || line.StartsWith("if(")) {  
        await HandleIf(line);  
        return;  
    }

    if (line.StartsWith("choice ") || line \== "choice{" || line.StartsWith("choice {")) {  
        await HandleChoice();  
        return;  
    }

    if (line.StartsWith("while ") || line.StartsWith("while(")) {  
        await HandleWhile(line);  
        return;  
    }

    if (line.StartsWith("return ") || line \== "return") {  
        HandleReturn(line);  
        return;  
    }

    if (IsBuiltinCall(line)) {  
        await ExecuteBuiltin(line);  
        pc++;  
        return;  
    }

    if (IsUserFunctionCall(line)) {  
        await ExecuteUserFunction(line);  
        pc++;  
        return;  
    }

    evaluator.ExecuteAssignment(line, state);  
    pc++;  
}

### **3.6 if文の処理**

// \=== TypeScript \===  
async handleIf(line: string): Promise\<void\> {  
  const condition \= this.parser.extractCondition(line)  
  const result \= this.evaluator.evaluateCondition(condition, this.state)

  if (result) {  
    this.pc++  
    await this.executeBlock()  
    this.skipElseChain()  
  } else {  
    this.pc \= this.parser.findBlockEnd(this.lines, this.pc) \+ 1  
    await this.handleElseChain()  
  }  
}

// \=== C\# \===  
private async Task HandleIf(string line) {  
    var condition \= parser.ExtractCondition(line);  
    var result \= evaluator.EvaluateCondition(condition, state);

    if (result) {  
        pc++;  
        await ExecuteBlock();  
        SkipElseChain();  
    } else {  
        pc \= parser.FindBlockEnd(lines, pc) \+ 1;  
        await HandleElseChain();  
    }  
}

### **3.7 choice の処理**

// \=== TypeScript \===  
async handleChoice(): Promise\<void\> {  
  const choiceNode \= this.parser.parseChoice(this.lines, this.pc)

  const options: ChoiceOption\[\] \= \[\]  
  const blocks: { start: number; end: number }\[\] \= \[\]

  for (const option of choiceNode.options) {  
    let visible \= true  
    if (option.condition) {  
      visible \= this.evaluator.evaluateCondition(option.condition, this.state)  
    }  
    if (visible) {  
      options.push({ text: option.text })  
      blocks.push({ start: option.bodyStart, end: option.bodyEnd })  
    }  
  }

  const selected \= await this.engine.showChoice(options)

  this.pc \= blocks\[selected\].start  
  await this.executeBlock()

  this.pc \= choiceNode.end \+ 1  
}

// \=== C\# \===  
private async Task HandleChoice() {  
    var choiceNode \= parser.ParseChoice(lines, pc);

    var options \= new List\<ChoiceOption\>();  
    var blocks \= new List\<(int start, int end)\>();

    foreach (var option in choiceNode.Options) {  
        var visible \= true;  
        if (option.Condition \!= null) {  
            visible \= evaluator.EvaluateCondition(option.Condition, state);  
        }  
        if (visible) {  
            options.Add(new ChoiceOption { Text \= option.Text });  
            blocks.Add((option.BodyStart, option.BodyEnd));  
        }  
    }

    var selected \= await engine.ShowChoice(options.ToArray());

    pc \= blocks\[selected\].start;  
    await ExecuteBlock();

    pc \= choiceNode.End \+ 1;  
}

### **3.8 関数呼び出しの処理**

// \=== TypeScript \===  
async executeUserFunction(line: string): Promise\<any\> {  
  const { name, args } \= this.parser.parseFunctionCall(line)  
  const funcDef \= this.state.functions.get(name)  
                || this.state.subroutines.get(name)

  if (\!funcDef) throw new Error(\`未定義の関数: ${name}\`)

  const evaluatedArgs \= args.map(a \=\> this.evaluator.evaluate(a, this.state))

  this.state.pushScope()  
  funcDef.params.forEach((param, i) \=\> {  
    this.state.setVar(param, evaluatedArgs\[i\])  
  })

  const returnPc \= this.pc \+ 1  
  this.pc \= funcDef.bodyStart

  let returnValue: any \= undefined  
  while (this.pc \<= funcDef.bodyEnd) {  
    const currentLine \= this.lines\[this.pc\].trim()  
    if (currentLine.startsWith("return")) {  
      returnValue \= this.handleReturn(currentLine)  
      break  
    }  
    await this.step()  
  }

  this.state.popScope()  
  this.pc \= returnPc

  return returnValue  
}

// \=== C\# \===  
private async Task\<object\> ExecuteUserFunction(string line) {  
    var (name, args) \= parser.ParseFunctionCall(line);  
    var funcDef \= state.Functions.GetValueOrDefault(name)  
                ?? state.Subroutines.GetValueOrDefault(name);

    if (funcDef \== null) throw new Exception($"未定義の関数: {name}");

    var evaluatedArgs \= args.Select(a \=\> evaluator.Evaluate(a, state)).ToArray();

    state.PushScope();  
    for (int i \= 0; i \< funcDef.Params.Length; i++) {  
        state.SetVar(funcDef.Params\[i\], evaluatedArgs\[i\]);  
    }

    var returnPc \= pc \+ 1;  
    pc \= funcDef.BodyStart;

    object returnValue \= null;  
    while (pc \<= funcDef.BodyEnd) {  
        var currentLine \= lines\[pc\].Trim();  
        if (currentLine.StartsWith("return")) {  
            returnValue \= HandleReturn(currentLine);  
            break;  
        }  
        await Step();  
    }

    state.PopScope();  
    pc \= returnPc;

    return returnValue;  
}

### **3.9 await ポイント**

インタプリタが一時停止し、外部入力を待つポイント。

| 場所 | 待機内容 |
| ----- | ----- |
| セリフ表示後 | クリック待ち |
| `choice { }` | プレイヤーの選択待ち |
| `wait(ms)` | 指定時間経過 |
| `waitclick()` | 明示的クリック待ち |
| `timeline(name)` | タイムライン再生完了 |
| `bg(name, "fade")` | トランジション完了 |

TypeScript では `Promise<void>` \+ `await`、C\# では `Task` \+ `async await`。 言語のasync機構が異なるがインタプリタのロジック上は同一の動作となる。

**Unity固有の注記:** Unity の `Task` は `UniTask` ライブラリの利用を推奨。標準の `Task` はUnityのメインスレッドとの連携に制約がある。`UniTask` は `async/await` をUnityのコルーチンシステム上で動かし、パフォーマンスも良い。

// UniTask 使用例  
using Cysharp.Threading.Tasks;

public interface IEngineAPI {  
    UniTask ShowDialogue(string speaker, string\[\] lines);  
    UniTask SetBg(string name, string effect \= null);  
    UniTask\<int\> ShowChoice(ChoiceOption\[\] options);  
    // ...  
}

---

## **4\. 式評価器の設計**

### **4.1 対応する式の種類**

// リテラル  
42, 3.14, "hello", true, false

// 変数参照  
affection, flag\_library, name

// 算術  
affection \+ 1, score \* 10, count % 3

// 比較  
affection \>= 5, name \== "太郎"

// 論理  
affection \>= 5 && flag\_library, \!dead

// 関数呼び出し  
mood(affection), max(a, b)

// 文字列補間（セリフ内）  
{name}のスコアは{score \* 10}点

### **4.2 トークナイザ**

入力文字列をトークン列に分解する。

// \=== TypeScript \===  
enum TokenType {  
  Number,         // 42, 3.14  
  String,         // "hello"  
  Boolean,        // true, false  
  Identifier,     // affection, mood  
  Operator,       // \+, \-, \*, /, %, \==, \!=, \>, \<, \>=, \<=, &&, ||, \!  
  Assign,         // \=, \+=, \-=, \*=, /=  
  LeftParen,      // (  
  RightParen,     // )  
  LeftBrace,      // {  
  RightBrace,     // }  
  Comma,          // ,  
  Keyword,        // if, else, while, def, sub, return, choice  
}

interface Token {  
  type: TokenType  
  value: string  
  position: number  
}

// \=== C\# \===  
public enum TokenType {  
    Number,  
    String,  
    Boolean,  
    Identifier,  
    Operator,  
    Assign,  
    LeftParen,  
    RightParen,  
    LeftBrace,  
    RightBrace,  
    Comma,  
    Keyword,  
}

public class Token {  
    public TokenType Type { get; set; }  
    public string Value { get; set; }  
    public int Position { get; set; }  
}

### **4.3 式評価の実装方針**

再帰下降パーサーで式を評価する。文法規則は言語に依存しない。

expression     → logic\_or  
logic\_or       → logic\_and ( "||" logic\_and )\*  
logic\_and      → equality ( "&&" equality )\*  
equality       → comparison ( ( "==" | "\!=" ) comparison )\*  
comparison     → addition ( ( "\>" | "\>=" | "\<" | "\<=" ) addition )\*  
addition       → multiplication ( ( "+" | "-" ) multiplication )\*  
multiplication → unary ( ( "\*" | "/" | "%" ) unary )\*  
unary          → ( "\!" ) unary | primary  
primary        → NUMBER | STRING | BOOLEAN | IDENTIFIER | function\_call | "(" expression ")"  
function\_call  → IDENTIFIER "(" arguments? ")"  
arguments      → expression ( "," expression )\*

**クロスプラットフォーム注記:** この文法規則がTypeScript/C\#両方の実装の共通仕様となる。再帰下降パーサーのメソッド構造は文法規則と1:1で対応するため、両言語で同一のメソッド群が生まれる。

### **4.4 実装の選択肢**

| 方式 | メリット | デメリット | クロスプラットフォーム |
| ----- | ----- | ----- | ----- |
| 再帰下降パーサー自作 | 完全制御、軽量 | 実装量がやや多い | ◎ 両言語で同一ロジック |
| `new Function()` 利用 | 実装最小 | セキュリティ、制御の制限 | ✗ JSのみ |
| 既存ライブラリ | 実装不要 | 依存追加、制限あり | △ 言語ごとに別ライブラリ |

**推奨: 再帰下降パーサー自作**

ノベルゲームで必要な式は限定的であり、200〜300行で実装可能。 `new Function()` はC\#に移植できないため、クロスプラットフォーム設計として不適。 自作パーサーなら TypeScript → C\# の移植がほぼ機械的な置換で完了する。

---

## **5\. 初級（@記法）→ 上級 変換仕様**

### **5.1 変換規則**

| 初級 | 上級 |
| ----- | ----- |
| `@bg school` | `bg("school")` |
| `@bg school fade=1000` | `bg("school", "fade")` |
| `@ch heroine happy right` | `ch("heroine", "happy", "right")` |
| `@ch_hide heroine` | `ch_hide("heroine")` |
| `@bgm daily` | `bgm("daily")` |
| `@se door_open` | `se("door_open")` |
| `@jump 告白` | `jump("告白")` |
| `@call 共通イベント` | `call("共通イベント")` |
| `@wait 1000` | `wait(1000)` |
| `@timeline confession` | `timeline("confession")` |
| `@set affection += 1` | `affection += 1` |
| `@if affection >= 5` | `if (affection >= 5) {` |
| `@elseif affection >= 3` | `} else if (affection >= 3) {` |
| `@else` | `} else {` |
| `@endif` | `}` |
| `#hero` | `#hero`（変換不要） |
| `#` | `#`（変換不要） |
| テキスト行 | テキスト行（変換不要） |
| `*ラベル名` | `*ラベル名`（変換不要） |

### **5.2 choice の変換**

// 初級  
@choice  
\- いいよ \-\> 一緒に帰る  
\- 用事がある \-\> 断る  
\- 図書室に行く \-\> 図書室 \[affection \>= 3\]

// ↓ 変換

// 上級  
choice {  
  "いいよ" {  
    jump("一緒に帰る")  
  }  
  "用事がある" {  
    jump("断る")  
  }  
  "図書室に行く" if (affection \>= 3\) {  
    jump("図書室")  
  }  
}

**注記:** 初級→上級コンパイラはTypeScriptでのみ実装する（エディタ/ツール側の機能）。C\#側は上級スクリプトのみを受け取る。

---

## **6\. セーブ/ロードの設計**

### **6.1 保存するデータ**

JSONフォーマット。TypeScript/C\#の両方で同一構造のJSON を読み書きする。

// \=== TypeScript \===  
interface SaveData {  
  scriptFile: string  
  pc: number  
  callStack: number\[\]  
  variables: Record\<string, any\>  
  display: {  
    bg: string  
    characters: CharacterState\[\]  
    bgm: string | null  
  }  
  timestamp: number  
  chapter: string  
  thumbnail?: string  
}

// \=== C\# \===  
\[Serializable\]  
public class SaveData {  
    public string ScriptFile;  
    public int Pc;  
    public int\[\] CallStack;  
    public Dictionary\<string, object\> Variables;  
    public DisplayState Display;  
    public long Timestamp;  
    public string Chapter;  
    public string Thumbnail;  
}

\[Serializable\]  
public class DisplayState {  
    public string Bg;  
    public CharacterState\[\] Characters;  
    public string Bgm;  
}

\[Serializable\]  
public class CharacterState {  
    public string Name;  
    public string Pose;  
    public string Position;  
}

### **6.2 セーブポイント**

セーブは任意のタイミング（awaitポイント）で可能。 `save()` でオートセーブポイントを明示的に設定できる。

### **6.3 ロード時の復元**

1. `SaveData` をJSONから読み込む  
2. `variables` を `GameState` に復元  
3. `display` 状態を即座に描画（トランジションなし）  
4. `pc` を復元してインタプリタを再開

**クロスプラットフォーム注記:** SaveData は JSON で保存するため、Web版で作成したセーブデータをUnity版で読み込むことも可能（ファイルアクセス方法のみ異なる）。

---

## **7\. エラーハンドリング**

### **7.1 エラー種別**

| 種別 | 例 | 処理 |
| ----- | ----- | ----- |
| 構文エラー | `if (affection >= )` | パース時に検出 |
| 未定義変数参照 | `undefined_var += 1` | 0/falseで初期化 or エラー |
| 未定義関数呼び出し | `unknown_func()` | エラー |
| 未定義ラベル参照 | `jump("存在しない")` | エラー |
| 型エラー | `"hello" * 3` | エラー |
| スタックオーバーフロー | 再帰呼び出し深度超過 | エラー |

### **7.2 エラー表示**

\[KNF Error\] line 42: 未定義の変数 'afection' — 'affection' ではありませんか？  
\[KNF Error\] line 58: 未定義のラベル '告白シーン' — jump先が見つかりません  
\[KNF Error\] line 73: 構文エラー — ')' が不足しています

行番号、エラー内容、可能であれば修正候補を表示する。

**クロスプラットフォーム注記:** エラーメッセージのフォーマットは統一する。出力先はプラットフォームで異なる（Web: console / UIオーバーレイ、Unity: Debug.LogError / UIオーバーレイ）。

### **7.3 デバッグモード**

開発時にはデバッグモードを有効にすることで以下の機能を提供:

* 変数ウォッチ（全変数の現在値をリアルタイム表示）  
* ブレークポイント（指定行で実行を一時停止）  
* ステップ実行（1行ずつ実行）  
* コンソール（実行中に式を評価、変数を書き換え）

---

## **8\. 完全なスクリプト例**

// \=== 第1章: 教室の朝 \===

// 変数初期化  
affection \= 0  
name \= "太郎"  
flag\_library \= false

// 関数定義  
def mood(aff) {  
  if (aff \>= 8\) return "happy"  
  if (aff \>= 4\) return "normal"  
  return "sad"  
}

sub shock\_effect() {  
  timeline("shock")  
  se("impact")  
}

// \=== ストーリー開始 \===

\*オープニング  
bg("school")  
bgm("daily")  
ch("hero", "normal", "left")

\#hero  
おはよう、今日もいい天気だな  
\#

ch("heroine", "smile", "right")

\#heroine  
うん、そうだね  
{name}くん、今日も早いんだね  
\#

affection \+= 1

// 選択肢  
choice {  
  "一緒に帰ろう" {  
    affection \+= 2  
    \#heroine  
    うん、いいよ！  
    \#  
    jump("一緒に帰る")  
  }  
  "用事があるんだ" {  
    affection \-= 1  
    \#heroine  
    そっか……  
    \#  
    jump("断る")  
  }  
  "図書室に寄らない？" if (affection \>= 3\) {  
    flag\_library \= true  
    \#heroine  
    行く行く！  
    \#  
    jump("図書室")  
  }  
}

// \=== 分岐 \===

\*一緒に帰る  
timeline("walk\_home\_happy")

\#heroine  
今日は楽しかったね  
\#

if (affection \>= 5 && flag\_library) {  
  \#heroine  
  ねえ、{name}くん  
  話したいことがあるの  
  \#  
  shock\_effect()  
  jump("告白")  
} else if (affection \>= 3\) {  
  \#heroine  
  また明日ね  
  \#  
  jump("通常エンド")  
} else {  
  \#heroine  
  じゃあね  
  \#  
  jump("通常エンド")  
}

\*告白  
timeline("confession\_scene")  
ch("heroine", mood(affection), "center")

\#heroine  
ずっと言えなかったけど……  
好きです  
\#

waitclick()  
jump("トゥルーエンド")

\*断る  
ch("heroine", "sad", "right")

\#heroine  
……わかった  
\#

bgm\_fade(2000)  
jump("通常エンド")

\*図書室  
bg("library")

\#heroine  
わあ、この本面白そう！  
\#

flag\_library \= true  
affection \+= 1  
jump("一緒に帰る")

\*通常エンド  
timeline("ending\_normal")  
bg("sunset")

\#hero  
今日も一日が終わる……  
\#

\*トゥルーエンド  
timeline("ending\_true")  
bg("cherry\_blossoms")  
bgm("ending\_theme")

\#hero  
これが、僕たちの始まりだった  
\#

---

## **9\. 実装ロードマップ**

### **9.1 TypeScript版（先行開発）**

| Phase | 内容 | 推定期間 |
| ----- | ----- | ----- |
| 1 | 行分類 \+ セリフ表示 \+ 組み込みコマンド | 1-2日 |
| 2 | ラベル \+ jump \+ call/ret | 1日 |
| 3 | 変数 \+ 代入 \+ 式評価器 | 2-3日 |
| 4 | if/else \+ choice | 2日 |
| 5 | 関数定義 \+ サブルーチン | 1-2日 |
| 6 | 文字列補間 | 0.5日 |
| 7 | セーブ/ロード | 1-2日 |
| 8 | エラーハンドリング \+ デバッグモード | 2-3日 |
| 9 | 初級→上級コンパイラ | 1-2日 |
|  | **小計** | **12-18日** |

### **9.2 C\#/Unity版（TypeScript版の移植）**

| Phase | 内容 | 推定期間 |
| ----- | ----- | ----- |
| 1 | コアクラス移植（Interpreter, Parser, Evaluator, GameState） | 2-3日 |
| 2 | UnityEngineAPI 実装 | 3-5日 |
| 3 | タイムラインランタイム移植 | 2-3日 |
| 4 | セーブ/ロード \+ Unity固有対応 | 1-2日 |
| 5 | テスト \+ TypeScript版との動作一致確認 | 2-3日 |
|  | **小計** | **10-16日** |

### **9.3 移植時の注意事項**

| 項目 | TypeScript | C\# |
| ----- | ----- | ----- |
| async/await | Promise | UniTask（推奨） |
| JSON読み書き | JSON.parse/stringify | JsonUtility / Newtonsoft.Json |
| ファイルアクセス | fetch / fs | Resources.Load / File.Read |
| 文字列操作 | slice, startsWith | Substring, StartsWith |
| 辞書型 | Map | Dictionary |
| 配列操作 | map, filter, forEach | Select, Where, ForEach (LINQ) |
| null判定 | `=== null || === undefined` | `== null` |
| 命名規則 | camelCase | PascalCase |

### **9.4 テスト戦略**

同一のテストスクリプト（.knf）をTypeScript版とC\#版の両方で実行し、出力が一致することを確認する。

テストスクリプト(.knf)  
    ├─→ TypeScript Interpreter → 実行ログ(JSON)  
    └─→ C\# Interpreter        → 実行ログ(JSON)  
                                      ↓  
                                 差分比較 → 一致すればOK

テストスクリプトには以下を含む:

* 全組み込みコマンドの呼び出し  
* 変数操作（全演算子）  
* if/else 全パターン  
* choice（条件付き含む）  
* 関数定義・呼び出し・再帰  
* 文字列補間  
* エラーケース

### **9.5 推定コード量**

| モジュール | TypeScript | C\# |
| ----- | ----- | ----- |
| Interpreter | \~80行 | \~90行 |
| Parser | \~150行 | \~160行 |
| Tokenizer | \~120行 | \~130行 |
| Evaluator | \~250行 | \~270行 |
| GameState | \~80行 | \~90行 |
| if/else処理 | \~70行 | \~75行 |
| choice処理 | \~60行 | \~65行 |
| 関数/サブルーチン | \~80行 | \~85行 |
| 組み込みコマンド | \~60行 | \~65行 |
| 文字列補間 | \~30行 | \~35行 |
| **コア合計** | **\~980行** | **\~1065行** |
| IEngineAPI実装 | \~300行 | \~400行 |
| **全体合計** | **\~1280行** | **\~1465行** |

C\#版はプロパティ構文、LINQ、null安全等により若干行数が増えるが、ロジックは同一。

