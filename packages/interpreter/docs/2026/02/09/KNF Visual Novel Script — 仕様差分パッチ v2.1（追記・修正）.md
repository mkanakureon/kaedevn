KNF Visual Novel Script — 仕様差分パッチ v2.1（追記・修正）

以下は **「KNF Visual Novel Script — 上級インタプリタ仕様書 v2」** に対する **v2.1 差分パッチ（追記・修正条文）** です。  
 そのまま仕様書末尾に **「v2.1 変更点」** として貼れる体裁にしてあります。  
---

# **KNF Visual Novel Script — 仕様差分パッチ v2.1（追記・修正）**

## **0\. 目的（v2.1）**

v2.1 では、実装の破綻点になりやすい箇所を **仕様として固定**し、TypeScript/C\# 両実装の一致性・デバッグ容易性・安全性を強化する。

---

## **1\. 呼び出し機構の統一（重要・必須）**

### **1.1 「呼び出しフレーム（CallFrame）」の導入（新設）**

`call(label)` / `ret()` および `def/sub` 呼び出しは、**同一の呼び出し機構**で処理する。  
 呼び出し状態は `CallFrame` に統一し、`callStack` は `Stack<CallFrame>` とする。

#### **CallFrame（共通仕様）**

* `returnPc`: 呼び出し元に戻るPC

* `scopeDepth`: 呼び出し時点のローカルスコープ深度

* `kind`: `"label"` / `"function"` / `"subroutine"`

* `returnVar`（任意）: return値の受け取り先（式として使用する場合）

* `source`（任意）: デバッグ用の呼び出し元情報（行番号・関数名）

これにより「ラベル呼び出し」と「関数/サブルーチン呼び出し」でスタック運用が分岐しない。

### **1.2 `callStack: number[]` を廃止（修正）**

* 旧：`callStack: number[]`

* 新：`callStack: CallFrame[]`

#### **GameState修正（概念）**

* `callStack: Stack<CallFrame>`

* `pushFrame(frame)`

* `popFrame(): CallFrame`

### **1.3 `return` と `ret()` の意味を固定（修正）**

* `ret()` は **`call(label)` の復帰**のための命令（値は返さない）

* `return expr` は **`def` の値返し**のための命令

* `sub` 内で `return expr` は **禁止**（構文エラー）

* `def` 内で `ret()` は **禁止**（構文エラー）

### **1.4 ユーザー関数呼び出しの実行方法（修正）**

`executeUserFunction()` の「関数内ループで step() を回す方式」は仕様上は許可するが、  
 **戻り先・スコープ復元は必ず CallFrame によって行う**。

* 呼び出し時：`pushScope()` → 引数束縛 → `pushFrame(returnPc, scopeDepth, kind="function")` → `pc = bodyStart`

* 復帰時：`popFrame()` → `pc = frame.returnPc` → `popScope()`（scopeDepthに戻す）→ returnValue を返す

「関数内で await が発生してもフレームが一貫して管理される」状態にする。

---

## **2\. 未定義変数の扱い（必須）**

### **2.1 参照（読み取り）時の規則（新設）**

**未定義変数の参照はエラー**とする。

例（エラー）:

* `x + 1`

* `if (flag_library) { ... }`

* `{name}`（補間中の参照）

エラーメッセージ例：  
 `未定義の変数 'afection' — 'affection' ではありませんか？`

### **2.2 複合代入に限り例外（新設・任意だが推奨）**

複合代入（`+=`, `-=`, `*=`, `/=`）の左辺が未定義の場合のみ、以下で暗黙初期化する。

* `+=` / `-=`：初期値 `0`

* `*=` / `/=`：初期値 `0`（ただし `/=` は 0除算チェックを行う）

ノベル側で「カウンタを雑に増やす」利便性を残しつつ、誤字は基本検出できる。

### **2.3 代入（`=`）は未定義でも常に許可（明文化）**

`x = expr` は新規変数作成として常に許可。

---

## **3\. 文字列補間 `{式}` の範囲を固定（必須）**

### **3.1 補間対象は「セリフブロック内のみ」（修正）**

v2で定義されていた「JS文字列リテラル内の `{式}`」補間は v2.1 で廃止する。  
 補間は **セリフブロック内**に限定する。

* 対象：`#speaker ... #` の内部行

* 非対象：`message = "{name}"` は **補間しない**（文字列として保持）

実装の複雑化（エスケープ・二重構文）を避け、クロスプラットフォーム一致性を上げる。

### **3.2 補間エラーの扱い（新設）**

補間 `{expr}` の評価でエラーが出た場合は、即時に実行停止しエラー表示する（サイレント失敗禁止）。

---

## **4\. ブロック書式制約（実装容易化・必須）**

### **4.1 `{` `}` の配置ルール（新設・強制）**

ブロック構文の解析を安定させるため、以下の書式制約を仕様として強制する。

#### **許可する形（v2.1）**

* `if (cond) {`（`{` は必ず行末）

* `} else if (cond) {`（この形のみ同一行許可）

* `} else {`（同一行許可）

* `}`（単独行）

#### **禁止する形（構文エラー）**

* `if (cond)` の次行に `{`

* `{` が単独行

* `} else` の次行に `{`

* `if (...) { foo() }` のような1行ブロック

`findBlockEnd` が「行単位のbraceカウント」で完結し、パーサーの複雑化を防ぐ。

### **4.2 セリフブロックと `{}` の関係（明文化）**

* セリフブロック中は `{` `}` をブロック記号として扱わない（単なる文字扱い）

* ブロック解析はセリフブロック外のみで行う

---

## **5\. while の扱い（v2.1 では無効化）**

### **5.1 while は予約語として保持するが実行不可（修正）**

`while` は将来拡張として予約語扱いに留め、v2.1 実装では **構文エラー**とする。

エラー例：  
 `while は v2.1 では未対応です（将来拡張）`

ループはデバッグ難度・無限ループ対策が重く、v2.1 の目的（安定実装）に反する。

---

## **6\. 組み込み関数（builtin）とユーザー定義の衝突規則（必須）**

### **6.1 組み込み関数名の予約（新設）**

組み込み関数名は **予約語**とし、変数・ユーザー関数・サブルーチンとして同名定義を禁止する。

例（禁止）:

* `bg = 1`

* `def bg(x) { ... }`

* `sub bg() { ... }`

### **6.2 呼び出し形の厳格化（新設）**

組み込み呼び出しは必ず `identifier "(" ... ")"` の形であることをトークナイズで確認し、単なる文字列判定（startsWith等）で実行してはならない。

---

## **7\. 変数の型制限（クロスプラットフォーム一致性）**

### **7.1 v2.1 の変数型（新設・推奨）**

セーブ互換と TS/C\# の一致テストを容易にするため、v2.1 の `variables` は以下に制限する。

* number

* boolean

* string

* null

配列・辞書・関数値は **禁止**（必要なら将来拡張）。

C\# の `Dictionary<string, object>` の JSON 往復で型ブレが起きやすいため、v2.1 は値型を絞る。

---

## **8\. 変更に伴う仕様書の置換指示（簡易）**

### **8.1 2.8節（文字列補間）の置換**

* 「セリフ内およびJSの文字列リテラル内」を

* 「セリフブロック内のみ」に置換

### **8.2 2.6.3節（while）の置換**

* 「将来拡張」記述は残して良いが、

* v2.1 では構文エラーであることを追記

### **8.3 6章（セーブ）への追記**

* `variables` 型制限（7.1）を追記

---

## **9\. v2.1 最小互換性テスト追加（推奨）**

v2.1 では以下を必須テストケースに追加する。

* `call(label)` → await（choice/timeline）→ `ret()` が正常復帰する

* `def` 内で `return` が値を返し、呼び出し元で利用できる

* 未定義参照が即エラーになる（補間含む）

* `{` 配置ルール違反が構文エラーになる

* builtin名の上書きが構文エラーになる

* variablesが number/boolean/string/null 以外を拒否する

---

以上。

このパッチを取り込むと、実装で一番揉める「呼び出し/復帰/await混在」と「ブロック検出」がかなり固まります。

次にやるなら、v2.1に合わせて **`CallFrame` を含むクラス定義（TS/C\#）** と、`executeUserFunction` / `call` / `ret` / `return` の **具体擬似コード**を一式にして渡せます。

