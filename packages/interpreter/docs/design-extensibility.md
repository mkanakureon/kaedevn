# 拡張性設計書

> Generated by Claude Opus 4.6

## 1. 概要

本書はインタプリタの拡張方法を解説する。新規コマンドの追加、IEngineAPI の拡張、カスタム関数の登録について、現在の手順と将来のプラグインアーキテクチャ計画を示す。

## 2. 新規コマンドの追加手順

### 2.1 概要

組み込みコマンドを追加するには 3 箇所の変更が必要:

1. `IEngineAPI` にメソッド追加
2. `Interpreter.executeBuiltin()` に case 追加
3. `Interpreter.isBuiltinFunction()` に名前追加

### 2.2 手順例: `screen_shake` コマンドの追加

**Step 1: IEngineAPI にメソッド追加**

```typescript
// src/engine/IEngineAPI.ts
export interface IEngineAPI {
  // ... 既存メソッド ...

  /**
   * 画面を揺らす
   * @param intensity 揺れの強さ (1-10)
   * @param duration 揺れの持続時間 (ミリ秒)
   */
  screenShake(intensity: number, duration: number): Promise<void>;
}
```

**Step 2: executeBuiltin に case 追加**

```typescript
// src/core/Interpreter.ts の executeBuiltin 内
case "screen_shake":
  await this.engine.screenShake(
    Number(args[0]),
    Number(args[1])
  );
  return true;  // PC をインクリメントする
```

**Step 3: isBuiltinFunction に名前追加**

```typescript
// src/core/Interpreter.ts
private isBuiltinFunction(name: string): boolean {
  const builtins = [
    // ... 既存の名前 ...
    "screen_shake",  // 追加
  ];
  return builtins.includes(name);
}
```

**Step 4: 各プラットフォームの IEngineAPI 実装を更新**

- Web 実装: PixiJS でカメラシェイクを実装
- MockEngine: テスト用ログ記録
- 他のプラットフォーム実装

**Step 5: テスト追加**

```typescript
it("screen_shake コマンドが動作する", async () => {
  const script = `screen_shake(5, 500)`;
  await interpreter.run(script);
  expect(engine.commandLog).toContain("screen_shake:5:500");
});
```

### 2.3 PC 制御コマンドの場合

`jump` / `call` / `ret` のように PC を直接操作するコマンドは、`executeBuiltin()` で `false` を返す:

```typescript
case "my_jump":
  this.pc = targetLine;
  return false;  // PC をインクリメントしない
```

## 3. IEngineAPI への新メソッド追加ガイド

### 3.1 メソッド設計の判断基準

| 問い | sync | async |
|---|---|---|
| 完了を待つ必要がある？ | No → sync | Yes → async |
| ユーザー入力を待つ？ | ― | async |
| アニメーションが伴う？ | ― | async |
| fire-and-forget で OK？ | sync | ― |

### 3.2 メソッドの命名規約

- 動詞 + 名詞（`showChar`, `playBgm`）
- 状態変更は `set` + 名詞（`setBg`）
- 停止は `stop` + 名詞（`stopBgm`）
- フェード系は `fade` + 名詞（`fadeBgm`）

### 3.3 引数の設計

- 必須引数を先に、オプション引数を後に
- 数値はすべて `number`（KSC の型システムに合わせる）
- ID 系は `string`
- 時間は常にミリ秒

## 4. カスタム組み込み関数の登録（将来計画）

### 4.1 現状

現在はカスタム関数を登録する API は存在しない。組み込みコマンドの追加にはソースコードの変更が必要。

### 4.2 将来の設計案

```typescript
// 将来の API 案
interpreter.registerCommand("screen_shake", {
  async: true,
  handler: async (args, engine, state) => {
    await engine.screenShake(Number(args[0]), Number(args[1]));
  },
});

// 式内で使える関数の登録
interpreter.registerFunction("clamp", {
  handler: (args) => {
    const [value, min, max] = args.map(Number);
    return Math.max(min, Math.min(max, value));
  },
});
```

### 4.3 実装に必要な変更

1. `Interpreter` にコマンド/関数レジストリを追加
2. `executeBuiltin()` でレジストリを参照
3. `functionCallHandler` でレジストリを参照
4. `isBuiltinFunction()` でレジストリを参照

## 5. プラグインアーキテクチャ（将来計画）

### 5.1 構想

```typescript
// プラグインインターフェース案
interface InterpreterPlugin {
  name: string;
  version: string;

  // カスタムコマンド
  commands?: Record<string, CommandHandler>;

  // カスタム関数（式内で使用可能）
  functions?: Record<string, FunctionHandler>;

  // ライフサイクルフック
  onInit?(interpreter: Interpreter): void;
  onBeforeStep?(line: number, content: string): void;
  onAfterStep?(line: number): void;
  onError?(error: Error): void;
}

// 使用例
interpreter.use(myPlugin);
```

### 5.2 ロードマップ

| フェーズ | 内容 | 状態 |
|---|---|---|
| 1 | コマンド登録 API | 計画中 |
| 2 | 式内関数登録 API | 計画中 |
| 3 | ライフサイクルフック | 未計画 |
| 4 | プラグインパッケージ | 未計画 |

## 6. 新構文の追加

新しい構文（例: `while` ループ）を追加する場合:

1. **Tokenizer**: 必要なら新しいトークン種別を追加
2. **Parser**: `classifyLine()` に分類ロジックを追加（必要なら）
3. **Interpreter**: `handleExpression()` に分岐を追加
4. **テスト**: 新構文のテストを追加

`while` の予約語はすでに Tokenizer に登録されているが、構文解析とループ実行のロジックは未実装。
