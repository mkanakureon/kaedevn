# スクリプト記述ガイド

> Generated by Claude Opus 4.6

.ksc（Kaede Script）の書き方を基本から上級まで段階的に解説する。

## 基本編 — セリフと背景

### セリフを表示する

```ksc
#narrator
ここは静かな図書館。
午後の陽射しが窓から差し込んでいる。
#

#hero
こんにちは。
今日はいい天気ですね。
#
```

- `#名前` でセリフブロックを開始
- `#` 単体でセリフブロックを終了
- 複数行のテキストは配列として IEngineAPI に渡される

### 背景を設定する

```ksc
bg("library")
bg("sunset", "fade")
```

### キャラクターを表示する

```ksc
ch("hero", "smile", "center")
ch("heroine", "angry", "left", 500)
ch_hide("hero")
ch_clear()
```

### 音声を再生する

```ksc
bgm("peaceful")
se("footstep")
voice("hero_001")
bgm_stop()
bgm_stop(1000)  // 1秒かけてフェードアウト
```

### 待機する

```ksc
wait(1000)    // 1秒待機
waitclick()   // クリック待ち
```

### コメント

```ksc
// これはコメントです（実行されません）
```

## 中級編 — 変数・条件分岐・選択肢

### 変数を使う

```ksc
// 変数の宣言と代入
affection = 0
name = "太郎"
is_rainy = false

// 算術演算
affection += 5
affection -= 2
score = affection * 10
```

### 条件分岐

```ksc
if (affection >= 10) {
  #heroine
  あなたのことが大好き！
  #
} else if (affection >= 5) {
  #heroine
  仲良くなれてうれしいな。
  #
} else {
  #heroine
  ...まだよく知らない人ね。
  #
}
```

条件式で使える演算子:
- 比較: `==`, `!=`, `>`, `>=`, `<`, `<=`
- 論理: `&&`（AND）, `||`（OR）, `!`（NOT）

```ksc
if (affection >= 5 && is_rainy == false) {
  // 好感度が5以上 かつ 雨でない
}

if (score > 80 || has_item == true) {
  // スコアが80超 または アイテムを持っている
}

if (!is_rainy) {
  // 雨でない
}
```

### 選択肢

```ksc
choice {
  "一緒に帰る" {
    affection += 3
    #heroine
    うれしい！
    #
  }
  "図書館に行く" {
    #hero
    今日は勉強しよう。
    #
  }
  "秘密の場所へ" if (affection >= 8) {
    // 好感度8以上の場合のみ表示される選択肢
    jump("secret_route")
  }
}
```

### ラベルとジャンプ

```ksc
*morning
bg("school_morning")
#narrator
朝のホームルーム。
#
jump("lunch")

*lunch
bg("cafeteria")
#narrator
昼休み。
#

*after_school
bg("school_sunset")
```

`jump` は指定したラベルに無条件で移動する。

### call と ret

```ksc
call("common_greeting")
// ↓ ret() で戻ってくる
#narrator
物語が続く...
#

*common_greeting
#hero
おはようございます！
#
ret()
```

`call` はラベルに移動し、`ret` で元の位置に戻る。

## 上級編 — 関数・サブルーチン・文字列補間

### 関数（def）— 値を返す

```ksc
def mood(aff) {
  if (aff >= 8) {
    return "happy"
  }
  if (aff >= 4) {
    return "normal"
  }
  return "sad"
}

def calculate_score(base, bonus) {
  return base * 2 + bonus
}

// 関数の呼び出しと戻り値の使用
current_mood = mood(affection)
total = calculate_score(10, 5)
```

### サブルーチン（sub）— 副作用専用

```ksc
sub show_status() {
  #narrator
  好感度: {affection}
  所持金: {gold}
  #
}

sub heal(amount) {
  hp += amount
  se("heal")
  #narrator
  HPが{amount}回復した！
  #
}

// 呼び出し
show_status()
heal(30)
```

- `sub` は値を返せない（`return 値` はエラー）
- `return` 単体で早期終了は可能

### 文字列補間

セリフブロック内で `{式}` を使うと、式の評価結果に置き換わる:

```ksc
name = "太郎"
score = 85
bonus = 15

#narrator
{name}さんのスコアは{score}点です。
ボーナスを加えると{score + bonus}点になります。
#
```

出力:
```
太郎さんのスコアは85点です。
ボーナスを加えると100点になります。
```

### 再帰関数

```ksc
def factorial(n) {
  if (n <= 1) {
    return 1
  }
  return n * factorial(n - 1)
}

result = factorial(5)
// result = 120
```

再帰の深度は最大 16 段まで。超過するとスタックオーバーフローエラーになる。

## 実践: ゲームシナリオの書き方

### 構造化のパターン

```ksc
// === 変数初期化 ===
affection = 0
route = "none"

// === 共通関数 ===
sub scene_transition(bg_name) {
  ch_clear(300)
  bg(bg_name, "fade")
  wait(500)
}

def check_route() {
  if (affection >= 15) {
    return "true_end"
  }
  if (affection >= 8) {
    return "good_end"
  }
  return "normal_end"
}

// === 本編 ===
*prologue
scene_transition("school_gate")

#narrator
桜が舞い散る、4月の朝。
#

*day1_morning
scene_transition("classroom")
ch("hero", "smile", "center")

#hero
新しいクラスか...
#

choice {
  "周りを見回す" {
    // 探索ルート
    jump("day1_explore")
  }
  "席に座る" {
    // 読書ルート
    jump("day1_reading")
  }
}

*day1_explore
ch("heroine", "surprised", "left")
affection += 2
#heroine
あ、あなたも転校生？
#
jump("day1_afternoon")

*day1_reading
// ...

*day1_afternoon
// ...

// === エンディング分岐 ===
*ending_check
route = check_route()
if (route == "true_end") {
  jump("true_ending")
} else if (route == "good_end") {
  jump("good_ending")
} else {
  jump("normal_ending")
}
```

### ベストプラクティス

1. **変数と関数はスクリプト冒頭に定義** — 実行時に先頭からスキャンされる
2. **シーン遷移はサブルーチンに** — 背景切り替え+フェードを統一
3. **ルート判定は関数に** — 条件を一箇所で管理
4. **ラベル名は階層的に** — `*day1_morning`, `*day1_afternoon` のようにプレフィックス付与
5. **コメントで構造を示す** — セクション区切りにコメントを活用
