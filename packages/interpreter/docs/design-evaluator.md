# 式評価器設計書

> Generated by Claude Opus 4.6

## 1. 概要

式評価は Tokenizer（字句解析）と Evaluator（構文解析＋評価）で構成される。Tokenizer は文字列をトークン列に変換し、Evaluator は再帰下降パーサーでトークン列を消費しながら値を計算する。

ソース: `src/core/Tokenizer.ts`, `src/core/Evaluator.ts`

## 2. Tokenizer の状態遷移

### 2.1 メイン状態遷移

```
[Start] → skipWhitespace → nextToken
                              │
              ┌───────────────┼───────────────┐──────────────┐
              ▼               ▼               ▼              ▼
         isDigit?        isQuote?      isIdentStart?    otherwise
              │               │               │              │
              ▼               ▼               ▼              ▼
        readNumber()    readString()   readIdentifier()  readOperatorOrSymbol()
              │               │               │              │
              ▼               ▼               ▼              ▼
         Token(Number)  Token(String)  Token(Id/Kw/Bool)  Token(Op/Assign/Paren/etc)
              │               │               │              │
              └───────────────┴───────────────┴──────────────┘
                                      │
                                      ▼
                              tokens.push(token)
                              → loop back to [Start]
```

### 2.2 readNumber の状態遷移

```
[Start] → digit* → [Integer]
                       │
                  "." found?
                  ├─ No → return Token(Number)
                  └─ Yes → digit* → return Token(Number)
```

### 2.3 readString の状態遷移

```
[Start] → skip quote → [InString]
                            │
                       ┌────┤────┐
                       ▼    │    ▼
                  char === "\" char === quote
                       │    │    │
                       ▼    │    ▼
                 readEscape  │  return Token(String)
                       │    │
                       ▼    │
                   value += │
                       │    │
                       └────┘
                    (continue loop)
```

### 2.4 readIdentifier のキーワード判定

```
[Start] → identChar* → value
                          │
              ┌───────────┼──────────────┐
              ▼           ▼              ▼
       value === "true"  isKeyword?    otherwise
       value === "false"      │              │
              │               ▼              ▼
              ▼        Token(Keyword)  Token(Identifier)
       Token(Boolean)
```

予約語リスト: `true`, `false`, `if`, `else`, `while`, `def`, `sub`, `return`, `choice`

### 2.5 readOperatorOrSymbol の判定

```
[Start] → peek 2 chars
              │
       ┌──────┼──────┐──────┐──────┐
       ▼      ▼      ▼      ▼      ▼
   assign2? comp2? logic2?  "="   other1?
   +=,-=    ==,!=  &&,||      │   +,-,*,/,
   *=,/=    >=,<=              │   %,>,<,!
       │      │      │        │      │
       ▼      ▼      ▼        ▼      ▼
  Assign   Operator Operator Assign Operator/Paren/Comma
```

## 3. Evaluator の再帰下降パーサー構造

### 3.1 メソッド階層

```typescript
// 優先度 1（最低）
async parseExpression(state) → parseLogicOr(state)

// 優先度 1: ||
async parseLogicOr(state):
  left = parseLogicAnd(state)
  while match("||"):
    advance()
    right = parseLogicAnd(state)
    left = isTruthy(left) || isTruthy(right)

// 優先度 2: &&
async parseLogicAnd(state):
  left = parseEquality(state)
  while match("&&"):
    advance()
    right = parseEquality(state)
    left = isTruthy(left) && isTruthy(right)

// 優先度 3: ==, !=
async parseEquality(state):
  left = parseComparison(state)
  while match("==", "!="):
    op = current().value; advance()
    right = parseComparison(state)
    left = (op === "==") ? left === right : left !== right

// 優先度 4: >, >=, <, <=
async parseComparison(state):
  left = parseAddition(state)
  while match(">", ">=", "<", "<="):
    op = current().value; advance()
    right = parseAddition(state)
    // switch on op...

// 優先度 5: +, -
async parseAddition(state):
  left = parseMultiplication(state)
  while match("+", "-"):
    op = current().value; advance()
    right = parseMultiplication(state)
    if op === "+":
      if typeof left === "string" || typeof right === "string":
        left = String(left) + String(right)  // 文字列結合
      else:
        left = left + right                   // 数値加算
    else:
      left = left - right

// 優先度 6: *, /, %
async parseMultiplication(state):
  left = parseUnary(state)
  while match("*", "/", "%"):
    op = current().value; advance()
    right = parseUnary(state)
    // switch on op...（/ で 0 除算チェック）

// 優先度 7（最高）: !, - (単項)
async parseUnary(state):
  if match("!", "-"):
    op = current().value; advance()
    operand = parseUnary(state)  // 右再帰
    return op === "!" ? !isTruthy(operand) : -operand
  return parsePrimary(state)
```

### 3.2 parsePrimary の処理フロー

```typescript
async parsePrimary(state):
  token = current()

  Number:
    advance(); return parseFloat(token.value)

  String:
    advance(); return token.value

  Boolean:
    advance(); return token.value === "true"

  Identifier:
    name = token.value; advance()
    if next is LeftParen:
      // 関数呼び出し
      advance()  // skip "("
      args = []
      if not RightParen:
        args.push(parseExpression(state))
        while Comma:
          advance(); args.push(parseExpression(state))
      expect RightParen; advance()
      return functionCallHandler(name, args)
    else:
      // 変数参照
      if !state.hasVar(name): throw "未定義の変数"
      return state.getVar(name)

  LeftParen:
    advance()  // skip "("
    expr = parseExpression(state)
    expect RightParen; advance()
    return expr

  default:
    throw "予期しないトークン"
```

## 4. 関数呼び出し解決

### 4.1 ハンドラーチェーン

Evaluator は `functionCallHandler` を通じて関数を実行する。Interpreter が設定するハンドラー:

```
式内の関数呼び出し
  │
  ├── ユーザー定義関数/サブルーチン → executeUserFunction()
  │     ├── 再帰深度チェック（16 段）
  │     ├── ローカルスコープ作成
  │     ├── 引数束縛
  │     ├── 関数本体実行
  │     └── 戻り値を返す
  │
  ├── 組み込み関数 → エラー
  │     └── "組み込み関数 'X' は式の中では使用できません"
  │
  └── 未定義 → エラー
        └── ErrorHandler.createFunctionNotFoundError()
            └── Levenshtein 距離で候補提案
```

## 5. 文字列補間の処理フロー

```
入力テキスト: "スコアは{score + 10}点です"
  │
  ▼
正規表現マッチ: /\{([^}]+)\}/g
  → matches: [{expr: "score + 10", fullMatch: "{score + 10}"}]
  │
  ▼
後ろから順に処理（インデックスずれ防止）:
  │
  ├── evaluate("score + 10", state) → 110
  ├── String(110) → "110"
  └── replace("{score + 10}", "110")
  │
  ▼
結果: "スコアは110点です"
```

## 6. ヘルパーメソッド

| メソッド | 役割 |
|---|---|
| `current()` | 現在のトークンを返す。範囲外なら EOF トークン |
| `advance()` | 現在位置を 1 進める |
| `match(...values)` | 現在のトークンの値が引数のいずれかに一致するか判定 |
| `isTruthy(value)` | 値の truthy/falsy 判定 |
