# IEngineAPI 実装ガイド

> Generated by Claude Opus 4.6

## 1. 概要

IEngineAPI はインタプリタとプラットフォーム固有の処理を分離する抽象層である。本書ではコンソール実装の完全コード例、Web 実装のヒント、よくある実装ミスと対処法を解説する。

## 2. 公式コンソール実装（ConsoleEngine）

パッケージに `ConsoleEngine` が含まれている。IEngineAPI の全17メソッドを実装しており、リファレンス実装として活用できる。

```typescript
import { Interpreter, ConsoleEngine } from "@kaedevn/interpreter";

const engine = new ConsoleEngine();
const interpreter = new Interpreter(engine);
await interpreter.run(script);
```

ソースコード: `src/engine/ConsoleEngine.ts`
詳細ガイド: [guide-console-engine.md](guide-console-engine.md)

## 3. テスト用 TestEngine

ゲーム状態を実際に管理する TestEngine。テストで「今どのキャラが表示されているか」「BGM が流れているか」を問い合わせできる。各メソッドが実際の状態管理を行うため、独自エンジン実装のリファレンスとしても使える。

```typescript
import type { IEngineAPI, ChoiceOption } from "@kaedevn/interpreter";

/** キャラクターの表示状態 */
interface CharState {
  pose: string;
  position: string;
  anim: boolean;
}

class TestEngine implements IEngineAPI {
  // ── 状態 ──
  currentBg: string | null = null;
  characters: Map<string, CharState> = new Map();
  currentBgm: { name: string; vol: number } | null = null;
  dialogues: Array<{ speaker: string; lines: string[] }> = [];
  choices: Array<{ options: string[]; selected: number }> = [];
  battles: Array<{ troopId: string; result: "win" | "lose" }> = [];

  // ── テスト制御 ──
  /** showChoice が順番に返すインデックス */
  choiceQueue: number[] = [];
  /** battleStart が順番に返す結果 */
  battleQueue: Array<"win" | "lose"> = [];

  // ── セリフ ──
  async showDialogue(speaker: string, lines: string[]) {
    this.dialogues.push({ speaker, lines });
  }

  /** 最後のセリフを取得 */
  get lastDialogue() {
    return this.dialogues[this.dialogues.length - 1] ?? null;
  }

  // ── 背景 ──
  async setBg(name: string, effect?: string) {
    this.currentBg = name;
  }

  // ── キャラクター ──
  async showChar(name: string, pose: string, position?: string, fadeMs?: number) {
    this.characters.set(name, { pose, position: position ?? "center", anim: false });
  }

  async showCharAnim(name: string, pose: string, position: string) {
    this.characters.set(name, { pose, position, anim: true });
  }

  async hideChar(name: string, fadeMs?: number) {
    this.characters.delete(name);
  }

  async clearChars(fadeMs?: number) {
    this.characters.clear();
  }

  async moveChar(name: string, position: string, time: number) {
    const ch = this.characters.get(name);
    if (ch) ch.position = position;
  }

  /** キャラクターが表示中か */
  isCharVisible(name: string): boolean {
    return this.characters.has(name);
  }

  /** キャラクターの現在ポーズ */
  getCharPose(name: string): string | null {
    return this.characters.get(name)?.pose ?? null;
  }

  /** キャラクターの現在位置 */
  getCharPosition(name: string): string | null {
    return this.characters.get(name)?.position ?? null;
  }

  // ── オーディオ ──
  playBgm(name: string, vol?: number, fadeMs?: number) {
    this.currentBgm = { name, vol: vol ?? 100 };
  }

  stopBgm() {
    this.currentBgm = null;
  }

  async fadeBgm(time: number) {
    this.currentBgm = null;
  }

  playSe(name: string, vol?: number) {
    // fire-and-forget: SE は状態を持たない
  }

  playVoice(name: string) {
    // fire-and-forget
  }

  /** BGM が再生中か */
  get isBgmPlaying(): boolean {
    return this.currentBgm !== null;
  }

  // ── タイムライン ──
  async playTimeline(name: string) {
    // no-op
  }

  // ── バトル ──
  async battleStart(troopId: string): Promise<"win" | "lose"> {
    const result = this.battleQueue.shift() ?? "win";
    this.battles.push({ troopId, result });
    return result;
  }

  // ── UI ──
  async showChoice(options: ChoiceOption[]): Promise<number> {
    const selected = this.choiceQueue.shift() ?? 0;
    this.choices.push({ options: options.map((o) => o.text), selected });
    return selected;
  }

  async waitForClick() {}
  async wait(ms: number) {}

  // ── リセット ──
  reset() {
    this.currentBg = null;
    this.characters.clear();
    this.currentBgm = null;
    this.dialogues = [];
    this.choices = [];
    this.battles = [];
    this.choiceQueue = [];
    this.battleQueue = [];
  }
}
```

**テスト例:**

```typescript
const engine = new TestEngine();
const interpreter = new Interpreter(engine);

await interpreter.run(`
bg("school")
bgm("daily")
ch("hero", "smile", "center")

#hero
こんにちは
#

ch("hero", "sad", "left")
ch_hide("heroine")
`);

// 背景の確認
expect(engine.currentBg).toBe("school");

// キャラクターの状態確認
expect(engine.isCharVisible("hero")).toBe(true);
expect(engine.getCharPose("hero")).toBe("sad");
expect(engine.getCharPosition("hero")).toBe("left");
expect(engine.isCharVisible("heroine")).toBe(false);

// BGM の確認
expect(engine.isBgmPlaying).toBe(true);
expect(engine.currentBgm?.name).toBe("daily");

// セリフの確認
expect(engine.dialogues).toHaveLength(1);
expect(engine.lastDialogue?.speaker).toBe("hero");
expect(engine.lastDialogue?.lines).toEqual(["こんにちは"]);
```

**選択肢の分岐テスト:**

```typescript
const engine = new TestEngine();
engine.choiceQueue = [1]; // 2番目の選択肢を選ぶ

const interpreter = new Interpreter(engine);
await interpreter.run(`
score = 0
choice {
  "勉強する" { score += 10 }
  "遊ぶ" { score += 5 }
}
`);

expect(engine.choices[0].selected).toBe(1);
expect(interpreter.getState().variables.score).toBe(5);
```

**バトル結果の制御:**

```typescript
const engine = new TestEngine();
engine.battleQueue = ["lose"]; // 敗北させる

const interpreter = new Interpreter(engine);
await interpreter.run(`
battle("boss", "win_label", "lose_label")
jump("end")
*win_label
result = "victory"
jump("end")
*lose_label
result = "defeat"
*end
`);

expect(engine.battles[0]).toEqual({ troopId: "boss", result: "lose" });
expect(interpreter.getState().variables.result).toBe("defeat");
```

## 4. Web（PixiJS）実装のヒント

### 4.1 showDialogue

```typescript
async showDialogue(speaker: string, lines: string[]): Promise<void> {
  // メッセージウィンドウにテキストを表示
  this.messageWindow.setSpeaker(speaker);
  this.messageWindow.setText(lines.join("\n"));
  this.messageWindow.show();

  // クリック待ち
  await new Promise<void>((resolve) => {
    this.stage.once("pointerdown", () => resolve());
  });
}
```

### 4.2 setBg

```typescript
async setBg(name: string, effect?: string): Promise<void> {
  const texture = await PIXI.Assets.load(`/assets/bg/${name}.webp`);
  const sprite = new PIXI.Sprite(texture);

  if (effect === "fade") {
    sprite.alpha = 0;
    this.bgContainer.addChild(sprite);
    // gsap や PIXI の Ticker でフェード
    await this.fadeIn(sprite, 500);
    // 古い背景を削除
  } else {
    this.bgContainer.removeChildren();
    this.bgContainer.addChild(sprite);
  }
}
```

### 4.3 showChoice

```typescript
async showChoice(options: ChoiceOption[]): Promise<number> {
  return new Promise<number>((resolve) => {
    const buttons: PIXI.Container[] = [];

    options.forEach((opt, index) => {
      const button = this.createChoiceButton(opt.text, index);
      button.on("pointerdown", () => {
        // ボタンを削除
        buttons.forEach((b) => b.destroy());
        resolve(index);
      });
      buttons.push(button);
      this.uiContainer.addChild(button);
    });
  });
}
```

### 4.4 wait

```typescript
async wait(ms: number): Promise<void> {
  await new Promise<void>((resolve) => setTimeout(resolve, ms));
}
```

## 5. 各メソッドの実装パターン

### 5.1 sync メソッド（fire-and-forget）

```typescript
// 再生開始のみ。完了を待たない
playBgm(name: string, vol?: number): void {
  const audio = this.audioManager.getBgm(name);
  if (vol !== undefined) audio.volume = vol / 100;
  audio.loop = true;
  audio.play();
}
```

### 5.2 async メソッド（完了待ち）

```typescript
// Promise で完了を通知
async hideChar(name: string, fadeMs?: number): Promise<void> {
  const sprite = this.characterSprites.get(name);
  if (!sprite) return;

  if (fadeMs && fadeMs > 0) {
    await this.fadeOut(sprite, fadeMs);
  }
  sprite.visible = false;
}
```

### 5.3 ユーザー入力待ち

```typescript
// ユーザーの操作を Promise で待機
async waitForClick(): Promise<void> {
  return new Promise<void>((resolve) => {
    const handler = () => {
      this.stage.off("pointerdown", handler);
      resolve();
    };
    this.stage.on("pointerdown", handler);
  });
}
```

## 6. よくある実装ミスと対処法

### 6.1 async メソッドが即座に resolve する

**問題**: `showDialogue` がクリックを待たずに resolve すると、テキストが一瞬で流れる。

**対処**: 必ずユーザー入力やアニメーション完了を `await` する。

### 6.2 showChoice が範囲外のインデックスを返す

**問題**: 返すインデックスが 0 始まりの範囲外。

**対処**: `return index` が `0 <= index < options.length` であることを保証する。

### 6.3 sync メソッドが Promise を返す

**問題**: `playBgm` が `async` で宣言されていると、インタプリタの動作には影響しないが、型の誤解を招く。

**対処**: sync メソッドは `void` を返すように実装する。`async` キーワードは付けない。

### 6.4 エラーが握りつぶされる

**問題**: メソッド内で try/catch してエラーを無視すると、スクリプトのバグが検出できない。

**対処**: 致命的でないエラーはログに出力しつつ、操作自体は継続する。致命的なエラーはそのままスローしてインタプリタに伝播させる。

### 6.5 fadeBgm と stopBgm の混同

**問題**: `bgm_stop(1000)` は `fadeBgm(1000)` を呼ぶべきだが、`stopBgm()` を呼んでしまう。

**対処**: この分岐は Interpreter 側で処理しているため、IEngineAPI 実装者は `stopBgm()` と `fadeBgm()` をそれぞれ正しく実装するだけでよい。
