# 状態管理仕様書

> Generated by Claude Opus 4.6

## 1. 概要

`GameState` クラスはインタプリタの実行状態を一元管理する。変数ストア、コールスタック、ラベルマップ、関数定義テーブルの 4 つのデータ構造で構成される。

ソース: `src/core/GameState.ts`

## 2. 内部構造

### 2.1 変数ストア — `variables`

```typescript
variables: Map<string, unknown> = new Map();
```

- グローバルスコープの変数を格納
- キー: 変数名（`string`）
- 値: `number | string | boolean | null`（型制約は仕様上のみ、ランタイムでは `unknown`）

### 2.2 ローカルスコープ — `localScopes`

```typescript
localScopes: Map<string, unknown>[] = [];
```

- 関数・サブルーチン呼び出し時に `pushScope()` で新しいスコープを追加
- `popScope()` でスコープを削除
- スタック構造（配列の末尾が最も内側のスコープ）

### 2.3 コールスタック — `callStack`

```typescript
callStack: CallFrame[] = [];
```

各 `CallFrame` の構造:

```typescript
interface CallFrame {
  returnPc: number;        // 復帰先の行番号
  scopeDepth: number;      // 呼び出し時のスコープ深度
  kind: "label" | "function" | "subroutine" | "method";
  returnVar?: string;      // 戻り値の代入先（未使用）
  thisRef?: unknown;       // method 呼び出し時の this（未使用）
  source?: {
    line: number;          // 呼び出し元の行番号
    name: string;          // 呼び出し元の名前（デバッグ用）
  };
}
```

### 2.4 ラベルマップ — `labelMap`

```typescript
labelMap: Map<string, number> = new Map();
```

- スクリプトロード時に `Parser.buildLabelMap()` で構築（1 パス）
- キー: ラベル名（`*` なし）
- 値: ラベル定義行の行番号（0 始まり）

### 2.5 関数定義テーブル — `functions` / `subroutines`

```typescript
functions: Map<string, FunctionDef> = new Map();
subroutines: Map<string, FunctionDef> = new Map();
```

各 `FunctionDef` の構造:

```typescript
interface FunctionDef {
  name: string;      // 関数名
  params: string[];  // 引数名のリスト
  bodyStart: number; // 本体開始行（def/sub の次の行）
  bodyEnd: number;   // 本体終了行（} の前の行）
}
```

## 3. スコープルール

### 3.1 変数参照の解決順序

`getVar(name)` は以下の順序で変数を検索する:

1. **ローカルスコープ（内側から外側へ）**: `localScopes[n-1]` → `localScopes[n-2]` → ... → `localScopes[0]`
2. **グローバルスコープ**: `variables`

最初に見つかった値を返す。どちらにも見つからない場合は `undefined` を返す（Evaluator 側で未定義エラーになる）。

### 3.2 変数設定の解決順序

`setVar(name, value)` は以下の順序で既存変数を検索する:

1. **ローカルスコープ（内側から外側へ）**: 既存の変数があればそのスコープで更新
2. **グローバルスコープ**: どのスコープにも存在しない場合はグローバルに新規作成

### 3.3 ローカル変数の束縛

`setLocalVar(name, value)` は最も内側のローカルスコープに変数を設定する。関数の引数束縛に使用される。ローカルスコープが存在しない場合はエラー。

### 3.4 グローバルとローカルの関係

```ksc
x = 10              // グローバル x = 10

def foo(x) {        // ローカル x（引数）
  x += 1            // ローカル x を更新
  return x
}

result = foo(5)     // result = 6
// x は依然として 10（グローバルは影響を受けない）
```

ただし、関数内でグローバル変数を新規作成することは可能:

```ksc
def setGlobal() {
  newVar = 42        // ローカルスコープに newVar はないため、グローバルに作成
}
```

## 4. call/ret のスタック操作

### 4.1 call(label) の処理

```
1. CallFrame を作成:
   - returnPc = 現在の PC + 1（call の次の行）
   - scopeDepth = localScopes.length
   - kind = "label"
   - source = { line: PC, name: "call(label)" }
2. callStack に push
3. PC をラベルの次の行に設定
```

### 4.2 ret() の処理

```
1. callStack から pop
2. frame が null → エラー「呼び出しスタックが空」
3. frame.kind !== "label" → エラー「ret() は call(label) の復帰専用」
4. PC を frame.returnPc に設定
```

### 4.3 def/sub 関数呼び出しの処理

```
1. 再帰深度チェック（16 段上限）
2. pushScope()（ローカルスコープ作成）
3. 引数をローカルスコープに束縛（setLocalVar）
4. CallFrame を push:
   - returnPc = 現在の PC
   - kind = "function" / "subroutine"
5. PC を関数本体の開始行に設定
6. 関数本体を実行（return または本体終了まで）
7. CallFrame を pop
8. popScope()（ローカルスコープ削除）
9. PC を復元
```

## 5. getState() で取得可能な情報

`Interpreter.getState()` は以下のオブジェクトを返す:

```typescript
{
  pc: number;                              // 現在のプログラムカウンタ
  variables: Record<string, unknown>;      // グローバル変数のスナップショット
  callStack: number;                       // コールスタックの深さ
}
```

- `variables` は `Map` を `Object.fromEntries()` で変換したもの
- ローカルスコープの変数は含まれない

## 6. セーブ / ロードとの関係

### 6.1 セーブ対象

CLAUDE.md で定義されたセーブスキーマ:

```json
{
  "save_schema_version": 1,
  "engine_version": "",
  "work_id": "",
  "scenario_id": "",
  "node_id": "",
  "vars": {},
  "read": {},
  "timestamp": 0
}
```

- `vars` フィールドに `getState().variables` を格納
- コールスタックやローカルスコープはセーブしない（セーブはシーン切り替え点で行う想定）

### 6.2 ロード

- `vars` を `GameState.variables` に復元
- `node_id` / `scenario_id` からスクリプトとラベルを特定して実行再開
