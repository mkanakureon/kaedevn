# クラス対応リファクタリング設計書

> Generated by Claude Opus 4.6

## 1. 背景

### 1.1 なぜクラスが必要か

Nintendo Switch 移植時に SDL2 ベースの IEngineAPI 実装が必要になる。SDL2 のリソース管理（テクスチャ、オーディオ、ウィンドウ）はオブジェクト指向で設計されており、スクリプト側からもオブジェクトを扱える方がエンジンとの橋渡しが自然になる。

具体的には:

- **キャラクターの状態管理**: 位置、ポーズ、アニメーション状態をオブジェクトとして保持
- **UI コンポーネント**: メッセージウィンドウ、選択肢パネルをオブジェクトとして操作
- **バトルシステム**: キャラクター/エネミーのステータスをクラスで表現
- **SDL2 リソースのライフサイクル**: テクスチャやサウンドの生成・破棄をオブジェクトに紐付け

### 1.2 現在の準備状況

CallFrame 型に既にクラス対応の予約がある:

```typescript
// src/types/CallFrame.ts
interface CallFrame {
  kind: "label" | "function" | "subroutine" | "method";  // ← "method" が予約済み
  thisRef?: unknown;  // ← メソッド呼び出し時の this 参照が予約済み
}
```

これらは現在未使用だが、クラス対応で活用される。

## 2. KSC クラス構文の設計

### 2.1 構文案

```ksc
// クラス定義
class Character {
  // プロパティ
  name = ""
  hp = 100
  position = "center"

  // コンストラクタ
  def init(name, hp) {
    this.name = name
    this.hp = hp
  }

  // メソッド（戻り値あり）
  def isAlive() {
    return this.hp > 0
  }

  // メソッド（副作用）
  sub takeDamage(amount) {
    this.hp -= amount
    se("hit")
    #narrator
    {this.name}は{amount}のダメージを受けた！
    残りHP: {this.hp}
    #
  }
}

// インスタンス生成
hero = new Character("太郎", 100)
enemy = new Character("ゴブリン", 50)

// メソッド呼び出し
enemy.takeDamage(30)
alive = hero.isAlive()

// プロパティアクセス
ch(hero.name, "smile", hero.position)
```

### 2.2 構文ルール

| 要素 | 構文 | 説明 |
|---|---|---|
| クラス定義 | `class Name { ... }` | 名前は大文字始まり推奨 |
| プロパティ | `name = value` | クラスブロック直下の代入 |
| コンストラクタ | `def init(args) { ... }` | `new` 時に自動呼び出し |
| メソッド（def） | `def methodName(args) { ... }` | 戻り値あり |
| メソッド（sub） | `sub methodName(args) { ... }` | 副作用専用 |
| インスタンス生成 | `var = new ClassName(args)` | `init` を呼び出し |
| メソッド呼び出し | `obj.method(args)` | `this` が自動束縛 |
| プロパティアクセス | `obj.property` | 読み取り |
| プロパティ設定 | `obj.property = value` | 書き込み |
| `this` | `this.property` | メソッド内でのみ使用可 |

## 3. 必要なリファクタリング

### 3.1 影響範囲

| モジュール | 変更内容 | 影響度 |
|---|---|---|
| **Tokenizer** | `.`（ドット）トークン、`new`/`class`/`this` キーワード追加 | 小 |
| **Parser** | クラス定義パース、`new` 式、ドットアクセス式の検出 | 中 |
| **Evaluator** | ドットアクセス評価、`new` 式評価、`this` 参照解決 | 大 |
| **GameState** | クラス定義テーブル、インスタンスの保持 | 中 |
| **Interpreter** | クラス定義のインデックス化、メソッド呼び出し処理 | 大 |
| **CallFrame** | `kind: "method"` と `thisRef` の活用 | 小（既に予約済み） |
| **IEngineAPI** | 変更なし | なし |

### 3.2 Tokenizer の変更

```typescript
// 追加するトークン種別
enum TokenType {
  // ... 既存 ...
  Dot = "Dot",       // .
  New = "New",       // new キーワード
}

// キーワードリストに追加
const keywords = [
  // ... 既存 ...
  "class", "new", "this"
];
```

### 3.3 Parser の変更

```typescript
class Parser {
  // 新規: クラス定義のパース
  parseClassDef(lines: string[], start: number): ClassDef;

  // 変更: classifyLine で "class " を検出
  classifyLine(line: string): LineType;
  // → LineType に ClassDef を追加
}
```

### 3.4 Evaluator の変更

```typescript
class Evaluator {
  // parsePrimary に追加:
  // - Identifier + "." → プロパティアクセス / メソッド呼び出し
  // - "new" + Identifier + "(" → インスタンス生成
  // - "this" → 現在の this 参照
}
```

### 3.5 GameState の変更

```typescript
class GameState {
  // 追加
  classes: Map<string, ClassDef> = new Map();
}

interface ClassDef {
  name: string;
  properties: Map<string, unknown>;  // デフォルト値
  methods: Map<string, FunctionDef>; // def メソッド
  subs: Map<string, FunctionDef>;    // sub メソッド
  initMethod?: FunctionDef;          // コンストラクタ
}

interface Instance {
  className: string;
  properties: Map<string, unknown>;  // インスタンス固有の値
}
```

### 3.6 CallFrame の活用

メソッド呼び出し時:

```typescript
this.state.pushFrame({
  returnPc: this.pc,
  scopeDepth: this.state.localScopes.length,
  kind: "method",       // ← 既存の予約を活用
  thisRef: instance,    // ← 既存の予約を活用
  source: {
    line: this.pc,
    name: `${instance.className}.${methodName}`,
  },
});
```

`this` の解決:

```typescript
// Evaluator の parsePrimary で "this" トークンを検出した場合
// → コールスタックを遡って最も内側の kind === "method" フレームを探す
// → frame.thisRef を返す
```

## 4. Nintendo Switch 対応構成（SDL2）

### 4.1 全体構成

```
packages/
├── interpreter/          # KSC インタプリタ（プラットフォーム非依存）
│   └── src/
│       ├── core/         # Interpreter, Parser, Evaluator, GameState
│       ├── engine/       # IEngineAPI（インターフェースのみ）
│       ├── debug/        # Debugger, ErrorHandler
│       └── types/        # 型定義
│
├── web/                  # Web 実装（PixiJS）
│   └── src/engine/
│       └── WebEngine.ts  # IEngineAPI の Web 実装
│
└── switch/               # Switch 実装（SDL2） ← 新規
    ├── src/
    │   ├── engine/
    │   │   └── SwitchEngine.ts    # IEngineAPI の SDL2 実装
    │   ├── sdl2/
    │   │   ├── Window.ts          # SDL_Window ラッパー
    │   │   ├── Renderer.ts        # SDL_Renderer ラッパー
    │   │   ├── TextureManager.ts  # SDL_Texture 管理
    │   │   ├── AudioManager.ts    # SDL_mixer 管理
    │   │   ├── FontManager.ts     # SDL_ttf 管理
    │   │   └── InputManager.ts    # SDL コントローラー入力
    │   ├── ui/
    │   │   ├── MessageWindow.ts   # セリフ表示 UI
    │   │   ├── ChoicePanel.ts     # 選択肢 UI
    │   │   └── DebugOverlay.ts    # デバッグ表示
    │   └── main.ts                # エントリーポイント
    ├── native/
    │   └── bindings.cpp           # SDL2 ネイティブバインディング
    └── assets/
        └── ...                    # Switch 用アセット
```

### 4.2 SwitchEngine（SDL2 IEngineAPI 実装）

```typescript
import type { IEngineAPI, ChoiceOption } from "@kaedevn/interpreter";

class SwitchEngine implements IEngineAPI {
  private renderer: SDL2Renderer;
  private textureManager: TextureManager;
  private audioManager: AudioManager;
  private fontManager: FontManager;
  private inputManager: InputManager;
  private messageWindow: MessageWindow;
  private choicePanel: ChoicePanel;

  // --- セリフ ---
  async showDialogue(speaker: string, lines: string[]): Promise<void> {
    this.messageWindow.setSpeaker(speaker);
    this.messageWindow.setText(lines.join("\n"));
    this.messageWindow.show();

    // Switch: A ボタン or タッチスクリーン待ち
    await this.inputManager.waitForConfirm();
    this.messageWindow.hide();
  }

  // --- 背景 ---
  async setBg(name: string, effect?: string): Promise<void> {
    const texture = this.textureManager.load(`bg/${name}.png`);

    if (effect === "fade") {
      await this.renderer.crossFade(this.currentBg, texture, 500);
    } else {
      this.renderer.setBackground(texture);
    }

    this.currentBg = texture;
  }

  // --- キャラクター ---
  async showChar(name: string, pose: string, position?: string, fadeMs?: number): Promise<void> {
    const texture = this.textureManager.load(`ch/${name}/${pose}.png`);
    const x = this.positionToX(position || "center");

    if (fadeMs && fadeMs > 0) {
      await this.renderer.fadeIn(texture, x, fadeMs);
    } else {
      this.renderer.drawSprite(texture, x);
    }
  }

  // --- オーディオ ---
  playBgm(name: string, vol?: number, fadeMs?: number): void {
    // SDL_mixer: Mix_PlayMusic / Mix_FadeInMusic
    const music = this.audioManager.loadMusic(`bgm/${name}.ogg`);
    if (fadeMs && fadeMs > 0) {
      this.audioManager.fadeInMusic(music, fadeMs, vol);
    } else {
      this.audioManager.playMusic(music, vol);
    }
  }

  stopBgm(): void {
    // SDL_mixer: Mix_HaltMusic
    this.audioManager.stopMusic();
  }

  async fadeBgm(time: number): Promise<void> {
    // SDL_mixer: Mix_FadeOutMusic
    await this.audioManager.fadeOutMusic(time);
  }

  playSe(name: string, vol?: number): void {
    // SDL_mixer: Mix_PlayChannel
    const chunk = this.audioManager.loadChunk(`se/${name}.wav`);
    this.audioManager.playChunk(chunk, vol);
  }

  playVoice(name: string): void {
    // 専用チャンネルでボイス再生
    const chunk = this.audioManager.loadChunk(`voice/${name}.wav`);
    this.audioManager.playVoice(chunk);
  }

  // --- UI ---
  async showChoice(options: ChoiceOption[]): Promise<number> {
    this.choicePanel.setOptions(options.map(o => o.text));
    this.choicePanel.show();

    // Switch: D-pad + A ボタンで選択
    const selected = await this.inputManager.waitForChoice(options.length);
    this.choicePanel.hide();
    return selected;
  }

  async waitForClick(): Promise<void> {
    // Switch: A ボタン or タッチスクリーン
    await this.inputManager.waitForConfirm();
  }

  async wait(ms: number): Promise<void> {
    // SDL_Delay 相当
    await new Promise(resolve => setTimeout(resolve, ms));
  }

  // --- タイムライン ---
  async playTimeline(name: string): Promise<void> {
    const timeline = this.loadTimeline(name);
    await this.renderer.executeTimeline(timeline);
  }

  // --- バトル ---
  async battleStart(troopId: string): Promise<"win" | "lose"> {
    // バトルシーンに遷移して結果を返す
    return await this.battleSystem.start(troopId);
  }
}
```

### 4.3 SDL2 モジュール構成

| モジュール | SDL2 API | 役割 |
|---|---|---|
| **Window** | `SDL_CreateWindow`, `SDL_DestroyWindow` | ウィンドウ管理 |
| **Renderer** | `SDL_CreateRenderer`, `SDL_RenderCopy`, `SDL_RenderPresent` | 2D 描画 |
| **TextureManager** | `SDL_CreateTextureFromSurface`, `IMG_LoadTexture` | テクスチャの読み込み・キャッシュ・破棄 |
| **AudioManager** | `Mix_OpenAudio`, `Mix_PlayMusic`, `Mix_PlayChannel` | BGM/SE/Voice の再生 |
| **FontManager** | `TTF_OpenFont`, `TTF_RenderUTF8_Blended` | テキストレンダリング |
| **InputManager** | `SDL_PollEvent`, `SDL_GameControllerOpen` | コントローラー・タッチ入力 |

### 4.4 Switch 入力マッピング

| Switch ボタン | KSC アクション | IEngineAPI 対応 |
|---|---|---|
| A | OK / 確認 / クリック | `waitForClick()`, `showChoice()` 決定 |
| B | Back / キャンセル | (将来: メニュー) |
| D-pad ↑↓ | 選択肢移動 | `showChoice()` カーソル移動 |
| + (Plus) | メニュー | (将来) |
| L/R | スキップ / オート | (将来) |
| ZL | クイックセーブ | (将来) |
| ZR | クイックロード | (将来) |
| タッチスクリーン | タップ = クリック | `waitForClick()`, `showChoice()` |

### 4.5 Switch 固有の制約

| 制約 | 対応 |
|---|---|
| メモリ制限（4GB 共有） | TextureManager でキャッシュサイズ上限を設定 |
| テクスチャ最大 2048px | CLAUDE.md のアセット制約に準拠 |
| 60fps 維持 | メインループを SDL_Delay で制御 |
| スリープ/レジューム | SDL_Event で検出、GameState を保持 |
| ドック/携帯モード切替 | `SDL_WINDOWEVENT_SIZE_CHANGED` で解像度再計算 |
| ファイルシステム | `romfs:/` からアセット読み込み |

### 4.6 クラスが SDL2 実装で活きる場面

```ksc
// スクリプト側でキャラクターをオブジェクトとして管理
class BattleUnit {
  name = ""
  hp = 0
  maxHp = 0
  atk = 0

  def init(name, hp, atk) {
    this.name = name
    this.hp = hp
    this.maxHp = hp
    this.atk = atk
  }

  def isAlive() {
    return this.hp > 0
  }

  sub attack(target) {
    damage = this.atk
    target.hp -= damage
    se("attack")
    #narrator
    {this.name}の攻撃！
    {target.name}に{damage}のダメージ！
    #
  }
}

// SDL2 側: TextureManager がキャラクター名からテクスチャを解決
// hero.name → "hero" → TextureManager.load("ch/hero/...")
hero = new BattleUnit("hero", 100, 15)
enemy = new BattleUnit("goblin", 50, 8)

ch(hero.name, "battle", "left")
ch(enemy.name, "battle", "right")

hero.attack(enemy)

if (enemy.isAlive()) {
  enemy.attack(hero)
}
```

この例では:
- `BattleUnit` クラスでステータスを管理
- `this.name` でキャラクター名を参照し、SDL2 のテクスチャ解決に使用
- `target.hp -= damage` でオブジェクト間のやり取り
- 組み込みコマンド（`ch`, `se`）とクラスメソッドが自然に共存

## 5. 実装ロードマップ

| フェーズ | 内容 | 依存 |
|---|---|---|
| **Phase 8-1** | Tokenizer にドット・new・this・class トークン追加 | なし |
| **Phase 8-2** | Parser にクラス定義パース追加 | 8-1 |
| **Phase 8-3** | GameState にクラス定義テーブル・Instance 型追加 | なし |
| **Phase 8-4** | Evaluator にドットアクセス・new 式・this 参照追加 | 8-1, 8-3 |
| **Phase 8-5** | Interpreter にクラスインデックス化・メソッド呼び出し追加 | 8-2, 8-3, 8-4 |
| **Phase 8-6** | テスト（クラス定義、インスタンス生成、メソッド呼び出し） | 8-5 |
| **Phase 9** | SDL2 バインディング + SwitchEngine 実装 | 8-6 |

## 6. 既存ドキュメントへの影響

既存の 24 ドキュメントは変更しない。クラス対応は本書と将来の Phase 8 実装レポートで管理する。既存ドキュメントとの関連:

| 既存ドキュメント | 関連 |
|---|---|
| `spec-ksc-language.md` | クラス構文は Phase 8 で言語仕様に追加予定 |
| `spec-expression.md` | ドットアクセス・new 式は Phase 8 で追加予定 |
| `spec-state-management.md` | クラス定義テーブル・Instance は Phase 8 で追加予定 |
| `design-architecture.md` | Switch 構成は Phase 9 で追加予定 |
| `design-extensibility.md` | クラスはプラグインシステムとは独立 |
| `api-reference.md` | 新しい型定義は Phase 8 完了後に追加予定 |
