# パーサー設計書

> Generated by Claude Opus 4.6

## 1. 概要

`Parser` クラスはスクリプトテキストを行単位で分類し、セリフブロック・ラベル・制御構文（if/choice/def/sub）のブロック構造を検出する。ステートレスな設計で、各メソッドは入力から直接結果を計算する。

ソース: `src/core/Parser.ts`

## 2. 行分類アルゴリズム

`classifyLine(line)` はトリム済みの行を受け取り、先頭文字で分類する:

```
入力: line (trimmed string)

if line === ""         → LineType.Empty
if line[0] === "#"
  if line.length === 1 → LineType.DialogueEnd
  else                 → LineType.DialogueStart
if line[0] === "*"     → LineType.Label
if line starts with "//" → LineType.Comment
else                   → LineType.Expression
```

### 2.1 判定の優先順位

1. 空行チェック
2. `#` チェック（セリフ開始/終了）
3. `*` チェック（ラベル）
4. `//` チェック（コメント）
5. フォールスルー（式/文）

この順序により、`#hero` はセリフ開始、`#` 単体はセリフ終了として正しく分類される。

## 3. セリフブロック検出

### 3.1 話者名抽出

```typescript
extractSpeaker(line: string): string
// "#hero" → "hero"
// "# " → ""（地の文）
```

`#` の後の文字列をトリムして返す。

### 3.2 セリフ終了検索

```typescript
findDialogueEnd(lines: string[], start: number): number
```

`start + 1` から順にスキャンし、`#` 単体の行を見つけて返す。見つからない場合は `lines.length` を返す。

## 4. ラベルインデックス構築

### 4.1 1 パススキャン

```typescript
buildLabelMap(lines: string[]): Map<string, number>
```

全行を 1 回スキャンし、`classifyLine()` が `Label` を返す行のラベル名と行番号を記録する。

```
パス 1: lines[0..n-1]
  for each line:
    if classifyLine(line) === Label:
      name = extractLabelName(line)  // "*start" → "start"
      labelMap.set(name, lineIndex)
```

- 同名ラベルが複数ある場合は後勝ち（最後の定義が有効）
- `extractLabelName()` は `*` の後の文字列をトリムして返す

## 5. ブロック終了検索

### 5.1 アルゴリズム

```typescript
findBlockEnd(lines: string[], start: number): number
```

ブレースカウントで `{ ... }` の対応を追跡:

```
braceCount = 0
foundFirstBrace = false

for i = start to lines.length - 1:
  line = lines[i].trim()

  // セリフブロック内はスキップ
  if line starts with "#" and line !== "#":
    i = findDialogueEnd(lines, i)
    continue

  for each char in line:
    if char === "{":
      braceCount++
      foundFirstBrace = true
    if char === "}":
      braceCount--
      if foundFirstBrace and braceCount === 0:
        return i

return lines.length - 1
```

### 5.2 セリフブロックのスキップ

ブレースカウント中にセリフブロック（`#name ... #`）が出現した場合、ブロック全体をスキップする。これにより、セリフ内の `{` `}` がブレースカウントに影響しない。

## 6. 関数/サブルーチン定義の検出

### 6.1 parseFunctionDef

```typescript
parseFunctionDef(lines: string[], start: number): FunctionDef
```

処理:

1. `start` 行を正規表現 `/^(def|sub)\s+(\w+)\s*\(([^)]*)\)\s*\{$/` でパース
2. 関数名、引数リストを抽出
3. `findBlockEnd(lines, start)` で本体の終了行を取得
4. `FunctionDef` を返す:
   - `name`: 関数名
   - `params`: 引数名の配列（カンマ区切り）
   - `bodyStart`: `start + 1`（定義行の次）
   - `bodyEnd`: `findBlockEnd() - 1`（`}` の前の行）

### 6.2 Interpreter.indexFunctions() との連携

Interpreter は `run()` 時に全行をスキャンし、`def` / `sub` で始まる行を `parseFunctionDef()` で解析して `GameState.functions` / `GameState.subroutines` に登録する。

## 7. if/else ブロックのネスト解析

Parser 自体は if/else のネスト解析を行わない。ブロック境界の検出（`findBlockEnd`）のみを担当し、実際の条件評価とブロック実行は Interpreter が制御する。

Interpreter の処理:
1. `handleIf()`: 条件を評価し、真なら `executeBlock()`、偽なら `findBlockEnd()` でスキップ
2. `executeBlock()`: ブレースカウントでブロック内を実行。`} else if` / `} else {` で現在のブロックを終了
3. `handleElseChain()`: 偽の場合に次の else if/else を探索
4. `skipElseChain()`: 真ブロック実行後に残りの else チェーンをスキップ

## 8. choice 構文の解析

### 8.1 parseChoice

```typescript
parseChoice(lines: string[], start: number): ChoiceNode
```

処理:

```
i = start + 1  // "choice {" の次の行

while i < lines.length:
  line = lines[i].trim()

  if line === "}":
    return ChoiceNode { options, end: i }

  if line === "" or line starts with "//":
    i++; continue

  // 選択肢パース: "テキスト" [if (条件)] {
  match = line.match(/^"([^"]+)"\s*(if\s*\((.+)\))?\s*\{$/)
  if match:
    text = match[1]
    condition = match[3]  // optional
    bodyStart = i + 1
    bodyEnd = findBlockEnd(lines, i)
    options.push({ text, condition, bodyStart, bodyEnd })
    i = bodyEnd + 1
  else:
    throw Error("choice構文の選択肢が正しくありません")

throw Error("choice構文が閉じられていません")
```

### 8.2 ChoiceNode 構造

```typescript
interface ChoiceNode {
  options: ChoiceOptionNode[];
  end: number;          // choice 全体の終了行（最後の }）
}

interface ChoiceOptionNode {
  text: string;         // 選択肢テキスト
  condition?: string;   // 表示条件式（if の中身）
  bodyStart: number;    // ブロック開始行
  bodyEnd: number;      // ブロック終了行
}
```
