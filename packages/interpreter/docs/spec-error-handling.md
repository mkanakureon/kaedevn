# エラーハンドリング仕様書

> Generated by Claude Opus 4.6

## 1. 概要

エラーハンドリングは `ErrorHandler` クラスと `KNFError` 型で構成される。構造化されたエラー情報（種別、行番号、スタックトレース、修正候補、コンテキスト）を提供し、開発者のデバッグを支援する。

ソース: `src/debug/ErrorHandler.ts`, `src/types/Error.ts`

## 2. エラー種別

```typescript
enum ErrorType {
  SyntaxError    = "SyntaxError",
  ReferenceError = "ReferenceError",
  TypeError      = "TypeError",
  RuntimeError   = "RuntimeError",
  StackOverflow  = "StackOverflow",
  FileNotFound   = "FileNotFound",
}
```

### 2.1 SyntaxError

| 発生条件 | メッセージ例 |
|---|---|
| if 文の構文不正 | `if文の構文が正しくありません` |
| else if 文の構文不正 | `else if文の構文が正しくありません` |
| 関数定義の構文不正 | `関数定義の構文が正しくありません` |
| choice 選択肢の構文不正 | `choice構文の選択肢が正しくありません` |
| choice が閉じられていない | `choice構文が閉じられていません` |
| 未知の文字 | `Unknown character at position N: X` |

### 2.2 ReferenceError

| 発生条件 | メッセージ例 |
|---|---|
| 未定義変数の参照 | `未定義の変数: varName` |
| 未定義関数の呼び出し | `未定義の関数: funcName` |
| 未定義ラベルへの jump/call | `未定義のラベル: labelName` |

### 2.3 TypeError

| 発生条件 | メッセージ例 |
|---|---|
| 代入左辺が変数でない | `代入の左辺は変数名である必要があります` |
| 予期しないトークン | `予期しないトークン: X` |
| 括弧不一致 | `閉じ括弧 ')' がありません` |

### 2.4 RuntimeError

| 発生条件 | メッセージ例 |
|---|---|
| 0 除算 | `0除算エラー` |
| 空スタックで ret() | `ret()が呼ばれましたが、呼び出しスタックが空です` |
| 非 label フレームで ret() | `ret()は call(label) の復帰専用です` |
| 関数外で return | `return文は関数/サブルーチン内でのみ使用できます` |
| sub 内で return expr | `サブルーチン内では値を返すreturnは使用できません` |
| label 内で return | `ラベルからの復帰は ret() を使用してください` |
| 引数数不一致 | `関数 'X' の引数の数が一致しません` |
| 表示可能選択肢なし | `表示可能な選択肢がありません` |
| 組み込み関数の式内使用 | `組み込み関数 'X' は式の中では使用できません` |
| 組み込み関数の戻り値使用 | `組み込み関数 'X' は値を返しません` |
| 組み込み関数名の予約 | `'X' は組み込み関数名です` |

### 2.5 StackOverflow

| 発生条件 | メッセージ例 |
|---|---|
| 再帰深度が 16 超過 | `再帰呼び出しの深度が上限（16）を超えました` |

## 3. KNFError 構造

```typescript
interface KNFError {
  type: ErrorType;          // エラー種別
  message: string;          // エラーメッセージ
  line: number;             // エラー発生行（1 始まり）
  column?: number;          // エラー発生列（オプション）
  stack: CallFrame[];       // スタックトレース
  suggestions?: string[];   // 修正候補
  context?: string;         // エラー発生箇所の前後コード
}
```

### 3.1 スタックトレース

```typescript
interface CallFrame {
  functionName: string;  // 関数名（"<main>" はトップレベル）
  line: number;          // 行番号（1 始まり）
  column?: number;       // 列番号
}
```

`Interpreter.buildErrorStack()` で構築:
1. 現在のコンテキストを `<main>` として追加
2. `GameState.callStack` を逆順で追加（`source` 情報を使用）
3. 配列を反転して返す

## 4. Levenshtein 距離による修正候補

### 4.1 アルゴリズム

`ErrorHandler.suggestSimilarVariables()` は動的計画法で Levenshtein 距離を計算する:

```
matrix[i][j] = min(
  matrix[i-1][j-1] + (b[i-1] === a[j-1] ? 0 : 1),  // 置換
  matrix[i][j-1] + 1,                                  // 挿入
  matrix[i-1][j] + 1                                   // 削除
)
```

### 4.2 フィルタ条件

候補として採用する条件:
- 編集距離が **3 以下**
- 編集距離が元の文字列長の **半分以下**

### 4.3 ソートと上限

- 編集距離が小さい順にソート
- 最大 **3 件** を返す

### 4.4 例

```
未定義変数: scroe
→ ヒント: 'score' ではありませんか？

未定義変数: afection
→ ヒント: 'affection' ではありませんか？
```

## 5. エラーメッセージのフォーマット

`ErrorHandler.formatError()` は以下の構成で出力する:

```
[KNF {ErrorType}] Line {line}: {message}
  at {functionName} (line {line})
  at {functionName} (line {line})

→ 5: score = 0
→ 6: scroe += 1    ← エラー行
→ 7: name = "Player"

ヒント: 'score' ではありませんか？
```

### 5.1 構成要素

1. **ヘッダー**: `[KNF {type}] Line {line}: {message}`
2. **スタックトレース**: `at {functionName} (line {line})` の列挙
3. **コンテキスト**: エラー行の前後 2 行（`→` でエラー行を強調）
4. **修正候補**: `ヒント:` に続く候補リスト

## 6. コンテキスト生成

`ErrorHandler.generateContext()` はエラー行の前後を表示する:

- デフォルト: 前後 **2 行** ずつ
- エラー行は `→` プレフィックス、それ以外は `  ` プレフィックス
- 行番号は 1 始まり

## 7. ErrorHandler のファクトリメソッド

| メソッド | 用途 | 引数 |
|---|---|---|
| `createReferenceError` | 未定義変数エラー | varName, line, availableVars, stack, script? |
| `createFunctionNotFoundError` | 未定義関数エラー | funcName, line, availableFuncs, stack, script? |
| `createTypeError` | 型エラー | message, line, stack, script? |
| `createRuntimeError` | 実行時エラー | message, line, stack, script? |
| `createStackOverflowError` | スタックオーバーフロー | line, stack |

## 8. Interpreter でのエラー拡張

`Interpreter.enhanceEvaluatorError()` は Evaluator からのエラーを検査し、未定義変数エラーの場合は `ErrorHandler.createReferenceError()` で再構築する。これにより、変数名の修正候補とスタックトレースが付与される。
