# FAQ・トラブルシューティング

> Generated by Claude Opus 4.6

## よくある質問

### Q: インストール方法は？

```bash
npm install @kaedevn/interpreter
```

ESM パッケージなので、`package.json` に `"type": "module"` が必要。

### Q: 最小限のコードで動かすには？

```typescript
import { Interpreter } from "@kaedevn/interpreter";
import type { IEngineAPI } from "@kaedevn/interpreter";

// 最小実装（全メソッドを no-op で実装）
const engine: IEngineAPI = {
  async showDialogue(s, l) { console.log(`${s}: ${l.join("\n")}`); },
  async setBg() {},
  async showChar() {},
  async showCharAnim() {},
  async hideChar() {},
  async clearChars() {},
  async moveChar() {},
  playBgm() {},
  stopBgm() {},
  async fadeBgm() {},
  playSe() {},
  playVoice() {},
  async playTimeline() {},
  async battleStart() { return "win" as const; },
  async showChoice(opts) { return 0; },
  async waitForClick() {},
  async wait() {},
};

const interpreter = new Interpreter(engine);
await interpreter.run(`
#hero
Hello World!
#
`);
```

### Q: TypeScript の型定義はどこにある？

`dist/index.d.ts` に含まれる。`import type { IEngineAPI } from "@kaedevn/interpreter"` で使用可能。

### Q: ブラウザで使えるか？

使える。外部依存がないため、バンドラー（Vite, webpack 等）でバンドルすれば動作する。

### Q: Node.js のバージョン要件は？

Node.js 20 以上。ESM のネイティブサポートが必要。

### Q: while ループはサポートされているか？

現在未実装。`while` は予約語として登録されているが、構文解析とループ実行のロジックは未実装。代替として、ラベルと jump を使ったループが可能:

```ksc
counter = 0
*loop
if (counter >= 10) {
  jump("end")
}
counter += 1
jump("loop")

*end
```

### Q: 配列やオブジェクトは使えるか？

現在未サポート。型システムは `number`, `string`, `boolean`, `null` の 4 型のみ。

### Q: 外部スクリプトの読み込み（import/include）はできるか？

現在未実装。1 つの `.ksc` ファイルが 1 つの実行単位。

## よくあるエラーと対処法

### `未定義の変数: xxx`

**原因**: 変数を使用する前に宣言していない。

**対処**: 変数を先に代入してから参照する。

```ksc
// NG
result = x + 1  // x が未定義

// OK
x = 0
result = x + 1
```

エラーメッセージに修正候補が表示される場合がある:
```
ヒント: 'score' ではありませんか？
```

### `未定義のラベル: xxx`

**原因**: `jump()` / `call()` で指定したラベルがスクリプト内に存在しない。

**対処**: ラベル名のスペルを確認。ラベルは `*` で定義:

```ksc
*my_label    // ← これが定義
jump("my_label")  // ← これが参照
```

### `ret()が呼ばれましたが、呼び出しスタックが空です`

**原因**: `call()` なしで `ret()` を実行した。

**対処**: `ret()` は `call()` とペアで使う:

```ksc
call("sub_routine")

*sub_routine
// 処理
ret()  // call 元に戻る
```

### `ret()は call(label) の復帰専用です`

**原因**: `def` / `sub` 関数内で `ret()` を使った。

**対処**: 関数からは `return` で抜ける:

```ksc
def foo() {
  return 42      // OK
  // ret()       // NG
}
```

### `サブルーチン内では値を返すreturnは使用できません`

**原因**: `sub` 内で `return 値` を使った。

**対処**: `sub` は値を返せない。`def` を使う:

```ksc
// NG
sub calc() {
  return 42
}

// OK
def calc() {
  return 42
}
```

### `組み込み関数 'bg' は式の中では使用できません`

**原因**: 式の中で組み込みコマンドを呼び出した。

**対処**: 組み込みコマンドは文として単独で呼び出す:

```ksc
// NG
result = bg("school")

// OK
bg("school")
```

### `再帰呼び出しの深度が上限（16）を超えました`

**原因**: 再帰関数の終了条件がないか、再帰が深すぎる。

**対処**:
1. 終了条件を確認
2. 再帰を浅くするアルゴリズムに変更
3. ラベル+jump によるループに置き換え

### `if文の構文が正しくありません`

**原因**: if 文のフォーマットが正しくない。

**対処**: 正しいフォーマットで記述:

```ksc
// OK
if (条件) {
  // 処理
}

// NG（括弧がない）
if 条件 {

// NG（{が同じ行にない）
if (条件)
{
```

### `choice構文の選択肢が正しくありません`

**原因**: choice 内の選択肢フォーマットが不正。

**対処**: 選択肢はダブルクォートで囲み、`{` で終わる:

```ksc
choice {
  "選択肢テキスト" {
    // 処理
  }
  "条件付き" if (flag) {
    // 処理
  }
}
```

## パフォーマンスの注意点

### 大量の変数操作

100 変数 × 2 回操作（計 200 行）は 500ms 以内で完了する。変数数が極端に多い場合は Map のルックアップコストに注意。

### 深い再帰

再帰は 16 段までに制限されている。深い再帰が必要な場合は、ラベルとジャンプを使ったイテレーティブな実装を検討する。

### 長いスクリプト

スクリプトの行数自体にはハードリミットはないが、ラベルマップと関数定義のインデックス構築は O(n) のコスト。

## デバッグモードの活用

```typescript
const interpreter = new Interpreter(engine, { debug: true });
const dbg = interpreter.getDebugger();

// 変数の変化を監視
dbg.watchVariable("affection");

// トレースログで関数呼び出しを追跡
dbg.enableTrace();

// 特定行にブレークポイント
dbg.addBreakpoint(15);
dbg.addBreakpoint(20, "score > 50");  // 条件付き

await interpreter.run(script);

// 結果を確認
console.log(dbg.getVariableHistory("affection"));
console.log(dbg.getTraceLog());
```
