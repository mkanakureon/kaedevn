# デバッグシステム設計書

> Generated by Claude Opus 4.6

## 1. 概要

デバッグシステムは `Debugger` クラスを中心に、ブレークポイント管理、変数ウォッチ、ステップ実行制御、トレースログ、イベントシステムを提供する。Interpreter とは疎結合に設計されており、デバッグモードの有効/無効でパフォーマンスへの影響を最小化している。

ソース: `src/debug/Debugger.ts`

## 2. Debugger クラス設計

### 2.1 内部状態

```typescript
class Debugger {
  private enabled: boolean;                          // デバッグモード有効/無効
  private watchedVars: Set<string>;                  // 監視対象変数
  private varHistory: Map<string, VariableChange[]>; // 変数変更履歴
  private breakpoints: Map<number, BreakpointInfo>;  // ブレークポイント（行番号→情報）
  private paused: boolean;                           // 一時停止中フラグ
  private stepMode: "none"|"over"|"into"|"out";      // ステップ実行モード
  private traceEnabled: boolean;                     // トレースログ有効/無効
  private traceLog: string[];                        // トレースログ
  private eventListeners: Array<(event) => void>;    // イベントリスナー
}
```

### 2.2 コンストラクタオプション

```typescript
constructor(options?: {
  enabled?: boolean;        // デバッグモード有効化
  watchVariables?: string[]; // 初期監視変数
  breakpoints?: number[];    // 初期ブレークポイント
  trace?: boolean;           // トレースログ有効化
})
```

### 2.3 Interpreter との接続

```typescript
// Interpreter コンストラクタ
this.debugger = new Debugger({ enabled: options?.debug ?? false });

// 外部アクセス
interpreter.getDebugger(): Debugger
```

## 3. ブレークポイント管理

### 3.1 BreakpointInfo

```typescript
interface BreakpointInfo {
  line: number;        // 行番号（1 始まり）
  condition?: string;  // 条件式（オプション）
  enabled: boolean;    // 有効/無効
}
```

### 3.2 API

| メソッド | 説明 |
|---|---|
| `addBreakpoint(line, condition?)` | ブレークポイント追加 |
| `removeBreakpoint(line)` | ブレークポイント削除 |
| `toggleBreakpoint(line, enabled)` | 有効/無効切り替え |
| `getBreakpoints()` | 全ブレークポイント取得 |

### 3.3 ブレーク判定フロー

```
Interpreter.step() 実行前:
  │
  ├── debugger.isEnabled() === false → スキップ
  │
  └── debugger.shouldBreak(line, state, evaluateCondition)
       │
       ├── ブレークポイント未設定 → false
       ├── ブレークポイント無効 → false
       ├── 条件なし → true（無条件ブレーク）
       └── 条件あり → evaluateCondition(condition, state)
            ├── true → ブレーク
            ├── false → 続行
            └── エラー → ブレーク（安全側）
```

## 4. 変数ウォッチ機構

### 4.1 VariableChange

```typescript
interface VariableChange {
  line: number;      // 変更発生行
  oldValue: unknown; // 変更前の値
  newValue: unknown; // 変更後の値
  timestamp: number; // タイムスタンプ（Date.now()）
}
```

### 4.2 API

| メソッド | 説明 |
|---|---|
| `watchVariable(name)` | 監視対象に追加 |
| `unwatchVariable(name)` | 監視を解除 |
| `getWatchedVariables()` | 監視変数一覧取得 |
| `getVariableHistory(name)` | 変更履歴取得 |

### 4.3 記録フロー

Interpreter の代入処理（`handleExpression` 内）:

```
1. 変数名を取得（varMatch）
2. 変更前の値を取得（state.getVar）
3. 代入を実行（evaluator.executeAssignment）
4. 変更後の値を取得
5. debugger.recordVariableChange(name, old, new, line)
   │
   ├── enabled === false → 何もしない
   ├── watchedVars.has(name) === false → 何もしない
   └── 履歴に追加 + イベント発火 + トレースログ記録
```

## 5. ステップ実行制御フロー

### 5.1 ステップモード

| モード | 動作 |
|---|---|
| `"none"` | 通常実行（ブレークポイントまで） |
| `"over"` | 次の行で停止（関数内には入らない） |
| `"into"` | 次の行で停止（関数内にも入る） |
| `"out"` | 現在の関数を抜けるまで実行 |

### 5.2 制御 API

| メソッド | 動作 |
|---|---|
| `pause()` | `paused = true` |
| `continue()` | `paused = false`, `stepMode = "none"` |
| `stepOver()` | `paused = false`, `stepMode = "over"` |
| `stepInto()` | `paused = false`, `stepMode = "into"` |
| `stepOut()` | `paused = false`, `stepMode = "out"` |

### 5.3 notifyStepComplete

ステップ実行が完了した際に呼び出される:

```
if stepMode !== "none":
  paused = true
  stepMode = "none"
  emit StepComplete event
```

## 6. デバッグイベントシステム

### 6.1 イベント型

```typescript
enum DebugEventType {
  VariableChanged = "variable_changed",
  Breakpoint      = "breakpoint",
  StepComplete    = "step_complete",
  FunctionCall    = "function_call",
  FunctionReturn  = "function_return",
}

interface DebugEvent {
  type: DebugEventType;
  line: number;
  data?: unknown;
}
```

### 6.2 イベントフロー

```
変数変更 → emit { type: VariableChanged, line, data: { name, oldValue, newValue } }
ブレーク → emit { type: Breakpoint, line }
ステップ完了 → emit { type: StepComplete, line }
関数呼び出し → emit { type: FunctionCall, line, data: { name, args } }
関数戻り → emit { type: FunctionReturn, line, data: { name, returnValue } }
```

### 6.3 リスナー API

```typescript
addEventListener(listener: (event: DebugEvent) => void): void
removeEventListener(listener: (event: DebugEvent) => void): void
```

リスナー内で例外が発生した場合は `console.error` で記録し、他のリスナーの実行は継続する。

## 7. トレースログ

### 7.1 API

| メソッド | 説明 |
|---|---|
| `enableTrace()` | トレースログ有効化 |
| `disableTrace()` | トレースログ無効化 |
| `addTrace(message)` | ログエントリ追加（ISO タイムスタンプ付き） |
| `getTraceLog()` | ログ全体のコピーを取得 |
| `clearTraceLog()` | ログをクリア |

### 7.2 自動記録内容

トレース有効時、以下が自動記録される:

- **変数変更**: `[Line N] varName changed: oldValue → newValue`
- **関数呼び出し**: `[Line N] call funcName(arg1, arg2)`
- **関数戻り**: `[Line N] funcName() returned value`

### 7.3 フォーマット

```
[2026-02-09T12:00:00.000Z] [Line 5] score changed: 0 → 10
[2026-02-09T12:00:00.001Z] [Line 8] call mood(10)
[2026-02-09T12:00:00.002Z] [Line 8] mood() returned "happy"
```

## 8. 外部ツール連携インターフェース

### 8.1 使用パターン

```typescript
const interpreter = new Interpreter(engine, { debug: true });
const dbg = interpreter.getDebugger();

// ブレークポイント設定
dbg.addBreakpoint(10);
dbg.addBreakpoint(20, "score > 50");  // 条件付き

// 変数ウォッチ
dbg.watchVariable("score");
dbg.watchVariable("health");

// トレース有効化
dbg.enableTrace();

// イベント監視
dbg.addEventListener((event) => {
  console.log(`[Debug] ${event.type} at line ${event.line}`);
});

// 実行
await interpreter.run(script);

// 結果取得
const history = dbg.getVariableHistory("score");
const trace = dbg.getTraceLog();
```

### 8.2 リセット

`dbg.reset()` で変更履歴、トレースログ、一時停止状態をクリアする。ブレークポイントと監視変数は保持される。
